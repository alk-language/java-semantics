<html>

<head>
    <meta charset="UTF-8">
<style>
      body {
    font-family: Roboto, sans-serif;
    line-height: 1.6;
    margin-left: 15%;
    margin-right: 15%;
    text-align: justify;
}

h1, h2, h3, h4, h5, h6 {
    color: #000c67;
}

h1 {
    font-weight: 700;
}

section {
    margin-bottom: 5%;
}

#toc_container {
    display: table;
    font-size: 95%;
}

#toc_container li, #toc_container ul, #toc_container ul li{
    list-style: none ;
}

footer {
    line-height: 0.5;
    color: #000c67;
}

table {
    margin: 10px auto 10px auto;
    border-collapse: collapse;
    border: 1px solid black;
}

td {
  padding: 8px;
}

th {
  padding: 8px;
  color: white;;
  background-color: #000c67;

}

</style>

    <link href="https://fonts.googleapis.com/css?family=Roboto:300,700" rel="stylesheet">
    <title>Alk Reference Manual</title>
</head>

<body>

    <h1> Alk Reference Manual </h1>
    
     <div id="toc_container">
        <ul class="toc_list">
            <li><a href="#introduction">1 Introduction</a>
              <ul>
                <li><a href="#introduction_1">1.1 Language motivation</a></li>
                <li><a href="#introduction_2">1.2 Configuration Principle</a></li>
              </ul>
            </li>
            <li><a href="#language">2 Language</a>
              <ul>
                <li><a href="#keywords">2.1 Keywords</a></li>
                <li><a href="#preprocessing">2.2 Preprocessing</a></li>
                <li><a href="#expressions">2.3 Expressions</a>
                  <ul>
                    <li><a href="#data-types">2.3.1 Data type values </a>
                      <ul>
                        <li><a href="#simple-types">2.3.1a Simple data type values </a>
                          <ul>
                            <li><a href="#integer">2.3.1a.1 Integer </a></li>
                            <li><a href="#float">2.3.1a.2 Float </a></li>
                            <li><a href="#bool">2.3.1a.3 Bool </a></li>
                            <li><a href="#string">2.3.1a.4 String </a></li>
                          </ul>
                        </li>
                        <li><a href="#compound-types">2.3.1b Compound data type values </a>
                          <ul>
                            <li><a href="#array">2.3.1b.1 Array </a></li>
                            <li><a href="#list">2.3.1b.2 List </a></li>
                            <li><a href="#set">2.3.1b.3 Set </a></li>
                            <li><a href="#structure">2.3.1b.3 Structure </a></li>
                          </ul>
                        </li>
                      </ul>
                    </li>
                    <li><a href="#operators">2.3.2 Data type operators</a>
                      <ul>
                        <li><a href="#unary-operator">2.3.2.1 Unary </a></li>
                        <li><a href="#id-operator">2.3.2.2 Increment/Decrement </a></li>
                        <li><a href="#artihmetic-operator">2.3.2.3 Arithmetic </a></li>
                        <li><a href="#bitwise-operator">2.3.2.4 Bitwise </a></li>
                        <li><a href="#setwise-operator">2.3.2.5 Setwise </a></li>
                        <li><a href="#relational-operator">2.3.2.6 Relational </a></li>
                        <li><a href="#inclusive-operator">2.3.2.7 Inclusive </a></li>
                        <li><a href="#logical-operator">2.3.2.8 Logical </a></li>
                        <li><a href="#conditional-operator">2.3.2.9 Conditional </a></li>
                      </ul>
                    </li>
                    <li><a href="#builtin-functions">2.3.3 Builtin Functions</a>
                      <ul>
                        <li><a href="#mathematical-functions">2.3.3.1 Mathematical </a></li>
                        <li><a href="#conversion-functions">2.3.3.2 Conversion </a></li>
                        <li><a href="#string-functions">2.3.3.3 String based </a></li>
                        <li><a href="#io-functions">2.3.3.4 IO </a></li>
                        <li><a href="#probabilistic-functions">2.3.3.5 Probabilistic </a></li>
                        <li><a href="#structural-functions">2.3.3.6 Structural </a></li>
                      </ul>
                    </li>
                    <li><a href="#builtin-methods">2.3.4 Builtin Methods</a>
                      <ul>
                        <li><a href="#query-builtin-methods">2.3.4.1 Query </a></li>
                        <li><a href="#update-builtin-methods">2.3.4.2 Update </a></li>
                      </ul>
                    </li>
                  </ul>
                </li>
                <li><a href="#declarations_initializations">2.4 Declarations and Initializations</a>
                  <ul>
                    <li><a href="#default-initialization">2.4.1 Default initialization values </a></li>
                    <li><a href="#dynamic-allocation">2.4.2 Dynamic allocation  </a></li>
                    <li><a href="#iterable-data-types">2.4.3 Iterable data types definition </a>
                      <ul>
                        <li><a href="#expression-representation">2.4.3.1 Expression based definition </a></li>
                        <li><a href="#interval-representation">2.4.3.2 Interval based definition </a></li>
                        <li><a href="#filter-representation">2.4.3.3 Filter specification based definition </a></li>
                        <li><a href="#map-representation">2.4.3.4 Map specification based definition </a></li>
                        <li><a href="#empty-representation">2.4.3.5 Empty definition </a></li>
                      </ul>
                    </li>
                  </ul>
                </li>
                <li><a href="#functions">2.5 Functions</a>
                  <ul>
                    <li><a href="#function-declaration">2.5.1 Function declaration</a></li>
                    <li><a href="#function-call-stmt">2.5.2 Function call</a></li>
                    <li><a href="#return-call">2.5.3 Return call</a></li>
                  </ul>
                </li>
                <li><a href="#instructions">2.6 Instructions</a>
                  <ul>
                    <li><a href="#simple-instructions">2.6.1 Simple intructions</a>
                      <ul>
                        <li><a href="#assignment">2.6.1.1 Assignment</a></li>
                        <li><a href="#function-call">2.6.1.2 Function Call</a></li>
                        <li><a href="#method-call">2.6.1.3 Method Call</a></li>
                        <li><a href="#id-instruction">2.6.1.4 Increment/Decrement</a></li>
                      </ul>
                    </li>
                    <li><a href="#compound-intructions">2.6.2 Compound instructions</a></li>
                    <li><a href="#conditional-instruction">2.6.3 Conditional instruction - if/else</a></li>
                    <li><a href="#repetitive-instrictions">2.6.4 Repetitve instructions</a>
                      <ul>
                        <li><a href="#while-instruction">2.6.4.1 While instruction</a></li>
                        <li><a href="#do-while-intruction">2.6.4.2 Do while instruction</a></li>
                        <li><a href="#repeat-until">2.6.4.3 Repeat until instruction</a></li>
                        <li><a href="#for-instruction">2.6.4.4 For instruction</a></li>
                        <li><a href="#foreach-instruction">2.6.4.5 Foreach instruction</a></li>
                        <li><a href="#break-continue">2.6.4.6 Break and continue instructions</a></li>
                      </ul>
                    </li>
                    <li><a href="#nondeterministic-instruction">2.6.5 Nondeterministic instructions</a>
                      <ul>
                        <li><a href="#choose-instruction">2.6.5.1 Choose/s.t. instruction</a></li>
                        <li><a href="#success-failure">2.6.5.2 Success and failure instructions</a></li>
                      </ul>
                    </li>
                    <li><a href="#probabilistic-instruction">2.6.6 Probabilistic instructions</a>
                      <ul>
                        <li><a href="#random-function">2.6.6.1 Random builtin function</a></li>
                        <li><a href="#uniform-instruction">2.6.6.2 Uniform instruction</a></li>
                      </ul>
                    </li>
                  </ul>
                </li>
              </ul>
            </li>
            <!--<li><a href="#executions">3 Executions</a>
                <ul>
                    <li><a href="#deterministic-executions">3.1 Deterministic executions</a></li>
                    <li><a href="#nondeterministic-executions">3.2 Nondeterministic executions</a>
                      <ul>
                        <li><a href="#exhaustive-execution">3.2.1 Exhaustive execution principle</a></li>
                        <li><a href="#nondeterministic-algorithm">3.2.2 Nondeterministic algorithm structure</a></li>
                        <li><a href="#final-configuration">3.2.3 Final configuration</a></li>
                      </ul>
                    </li>
                    <li><a href="#probabilistic-execution">3.3 Probabilistic executions</a></li>
                </ul>
            </li>
            <li><a href="#error-undestanding">4 Error understanding</a>
                <ul>
                    <li><a href="#error-format">4.1 Error format </a></li>
                    <li><a href="#debug-technique">4.2 Debug techniques </a></li>
                </ul>
            </li>-->
            <li><a href="#options">3 Options</a>
                <ul>
                    <li><a href="#option-a">3.1 Setting the algorithm to be run </a></li>
                    <li><a href="#option-i">3.2 Setting the initial configuration </a></li>
                    <li><a href="#option-p">3.3 Setting the precision</a></li>
                    <li><a href="#option-m">3.4 Show the metadata</a></li>
                    <li><a href="#option-z">3.5 Increase maximum allocation size</a></li>
                    <li><a href="#option-e">3.6 Trigger exhaustive execution</a></li>
                    <li><a href="#option-h">3.7 Help and version</a></li>
                </ul>
            </li>
        </ul>
    </div>

    <section id="introduction">
        <h1> 1 Introduction </h1>
        <section id="introduction_1">
          <h2> 1.1 Language motivation </h2>
          Alk is a programming language developed by the Alk Language Community, mainly formed by developers and professors of Faculty of Computer Science, University "Alexandru Ioan Cuza" University, Iasi. It firstly came out as an educational tool in 2016, meant to be used by the freshmen in order to develop and run specific algorithms. <br>

          Its main purpose is to deliver a system easy to use and platform-independent, as its main user target is the students. Due to its educational reasons, Alk should display as many theoretical principles as possible in a light-weighted environment: no heavy dependencies, allow a flexible syntax and intuitive semantics.
        </section>
        <section id="introduction_2">
          <h2> 1.2 Configuration principle </h2>
          A configuration refers to a set of mappings between ids and values. Semantically, this represents an environment state at a given moment. Its main usage is related to Alk's input configuration and eventually the final metadata. Note than a configuration can have more than one such mapping. In case multiple mappings are defined, they should be space separated. It is recommended to keep these cells on separate lines where possible to increase visibility.<br>

          <table border = 1>
            <tr><th>Syntax</th></tr>
            <tr><td><code>var-name |-> value</code></td></tr>
            <tr><td><code>var-name1 |-> value1 <br> var-name2 |-> value2</code></td></tr>
          </table>

          <b>Var-name:</b><br>
          This refers to the variable name to which the given value will be assigned. <br>
          <b>Value:</b><br>
          The value can be represented in any way. When an initial configuration is used, the Alk interpreter will parse the value as it does inside a normal Alk algorithm, which means that any kind of representation can be used (for example the interval or specification representations for an iterable data type value). <br>

          Alk allows the initialization of the environment through an input configuration, which can be specified by using the <a href="#option-i">input option (-i)</a>. Also, if the <a href = "#option-m">metadata option (-m)</a> is used, the final configuration will be printed.
          <ul>
            <b>Examples:</b>
            <li>Configuration with only one component: <code>a |-> 5</code></li>
            <li>Configuration with multiple components: <code>a |-> 5 b |-> 6.5 c |-> "abc" d |-> true e |-> [1, 2, 3] f |-> <1, 2, 3> g |-> {1, 2, 3} h |-> {x -> 1 y -> 2}</code></li>
            <li>Configuration making use of the Alk interpreter for parsing complex representations: <code>a |-> [2 * x | x from [1..10]]</code></li>
          </ul>

        </section>
    </section>

    <section id="language">
        <h1> 2 Language </h1>

        <section id="keywords">
          <h2> 2.1 Keywords </h2>
          Below there is a table of all the keywords which can be interpreted. Alongside, there is a short description containing links to the topics which exploit those keywords.
          <table border = 1>
            <tr><th>Keyword</th><th>Description</th></tr>
            <tr><td><code>break</code></td><td>Part of the <a href="#break-continue">break statement</a></td></tr>
            <tr><td><code>choose</code></td><td>Part of the <a href="#choose-instruction">choose statement</a></td></tr>
            <tr><td><code>continue</code></td><td>Part of the <a href="#break-continue">continue statement</a></td></tr>
            <tr><td><code>do</code></td><td>Part of the <a href="#do-while-intruction">do-while statement</a></td></tr>
            <tr><td><code>else</code></td><td>Part of the <a href="#conditional-instruction">conditional statement</a></td></tr>
            <tr><td><code>emptyList</code></td><td>Used to defined empty <a href="#list">list</a></td></tr>
            <tr><td><code>emptySet</code></td><td>Used to defined empty <a href="#set">set</a></td></tr>
            <tr><td><code>for</code></td><td>Part of the <a href="#for-instruction">for statement</a></td></tr>
            <tr><td><code>foreach</code></td><td>Part of the <a href="#foreach-instruction">foreach statement</a></td></tr>
            <tr><td><code>from</code></td><td>Used to represent <a href="#iterable-data-types">specifications</a></td></tr>
            <tr><td><code>failure</code></td><td>Part of the <a href="#success-failure">failure statement</a></td></tr>
            <tr><td><code>if</code></td><td>Part of the <a href="#conditional-instruction">conditional statement</a></td></tr>
            <tr><td><code>in</code></td><td>Used as <a href="#inclusive-operator">inclusive operator</a></td></tr>
            <tr><td><code>include</code></td><td>Part of the <a href="#preprocessing">include directive</a></td></tr>
            <tr><td><code>modifies</code></td><td>Used to represent <a href="#functions">global references inside functions</a></td></tr>
            <tr><td><code>out</code></td><td>Used to represent <a href="#functions">output parameters</a></td></tr>
            <tr><td><code>repeat</code></td><td>Part of the <a href="#repeat-until">repeat-until statement</a></td></tr>
            <tr><td><code>return</code></td><td>Part of the <a href="#return-call">return statement</a></td></tr>
            <tr><td><code>s.t.</code></td><td>Part of the <a href="#choose-instruction">choose statement</a></td></tr>
            <tr><td><code>success</code></td><td>Part of the <a href="#success-failure">success statement</a></td></tr>
            <tr><td><code>uniform</code></td><td>Part of the <a href="#uniform-instruction">uniform statement</a></td></tr>
            <tr><td><code>until</code></td><td>Part of the <a href="#repeat-until">repeat-until statement</a></td></tr>
            <tr><td><code>while</code></td><td>Part of the <a href="#while-instruction">while statement</a></td></tr>
            <tr><td><code>xor</code></td><td>Used as <a href="#bitwise-operator">xor operator</a></td></tr>
          </table>
        </section>

        <section id="preprocessing">
          <h2> 2.2 Preprocessing </h2>
          The preprocessing is a stage before the visiting one, which handles the directives. The only directive supported now is the include directive which allows the user to attach an external file into the current code-base. These directives are processed recursively, so the final generated program should have no include node. In case a cycle is detected, the Alk interpreter will report this and abort the execution. <br>

          <table border = 1>
            <tr><th>Syntax</th></tr>
            <tr><td><code>#include "file-path"</code></td></tr>
          </table>

          <b>File-path:</b><br>
          The file path should point to a file which should be included in this current code. The inclusion will be done where the directive is used. In fact, this directive will be automatically replaced with the content of the file specified. The path can be absolute or relative. If the relative path is used, the origin is the file which includes it, not the initial file which is used in the -a option.<br>

          <b>Examples: </b>
          <table border = 1>
            <tr><th>Initial file</th><th>Secondary file (<code>side.alk</code>)</th><th>Final configuration</th></tr>
            <tr><td><code>#include "side.alk"<br>b = a + 2;</code></td><td><code>a = 5;</code></td><td><code>a |-> 5<br>b |-> 7</code></td></tr>
            <tr><td><code>a = 9;<br>#include "side.alk"<br>b = a + 2;</code></td><td><code>a++;</code></td><td><code>a |-> 10<br>b |-> 12</code></td>
            <tr><td><code>a = 9;<br>b = a + 2;<br>#include "side.alk"</code></td><td><code>a++;</code></td><td><code>a |-> 10<br>b |-> 11</code></td></tr>
          </table>
        </section>

        <section id="expressions">
          <h2> 2.3 Expressions </h2>

          <section id="data-types">
            <h3> 2.3.1 Data type values </h3>

            <section id="simple-types">
              <h4> 2.3.1a Simple data type values </h4>

              <section id="integer">
                <h5> 2.3.1a.1 Integer</h5>
                The integer data type is a numeric type which allows storing data in form of integer numbers. There is no fixed bound for the dimension
                of one integer, as it is backed by an unlimited data structure designed for numeric usage. The complexity of the operations is dependent
                upon the size of the integer, thus not all computations should be considered to be working in constant time. <br>
                To represent an integer, one should just simply write it in the decimal base, as this is the only way Alk can interpret it.
                For negative integers, the <a href="#unary-operator">unary operator</a> <code>-</code> should be used in the representation. <br>
                <ul>
                  <b>Examples:</b>
                  <li>Integer: <code>123456789</code></li>
                  <li>Integer with a large number of digits: <code>1234567891011121314151617181920</code></li>
                  <li>Integer with minus sign: <code>-123</code></li>
                  <li>Zero integer: <code>0</code></li>
                </ul>
              </section>

              <section id="float">
                <h5> 2.3.1a.2 Float</h5>
                The float data type is a numeric type which allows storing data in form of numbers with floating point. There is no fixed bound for the dimension
                of the integer part, while the fractional part is limited by a <i>precision</i> constant. By default, the precision is set to 10 decimals after
                the floating point and rounded after a <i>HALF_EVEN</i> strategy. However this can be changed at the command line using the <a href="#option-p">precision option</a>.
                The complexity of the operations is dependent upon the size of the float, thus not all computations should be considered to be working in constant time. <br>
                To represent a float, one should write it in the decimal base using a floating point which separates the integer part from the fractional part. 
                These two parts should not be empty. The fractional part shouldn't necessarily respect the precision, it will be automatically trimmed. For negative 
                floats, the <a href="#unary-operator">unary operator</a> <code>-</code> should be used in the representation. <br>
                <ul>
                  <b>Examples:</b>
                  <li>Float: <code>1234.098765</code></li>
                  <li>Float with a large number of digits and decimals: <code>123456789.201918171615141312111</code></li>
                  <li>Float with minus sign: <code>-123.456</code></li>
                  <li>Float with 0 integer part: <code>0.123</code></li>
                  <li>Float with 0 fractional part: <code>123.0</code></li>
                  <li>Zero float: <code>0.0</code></li>
                </ul>                
              </section>

              <section id="bool">
                <h5> 2.3.1a.3 Bool</h5>
                The bool data type is a logical type which allows storing data in form of logical primitives. Therefore, a bool can have one out of the two possible
                values: <code>true</code> or <code>false</code>. The complexity of the operations with such types should be considered constant. <br>
                To represent a bool, one should write it using the <code>true</code> or <code>false</code> keywords. <br>
                <ul>
                  <b>Examples:</b>
                  <li>True bool: <code>true</code></li>
                  <li>False bool: <code>false</code></li>
                </ul>                 
              </section>

              <section id="string">
                <h5> 2.3.1a.4 String</h5>
                The string data type is a character type which allows storing data in form of character strings. There is no fixed bound for the length of the string
                and can be used as a single character representation when its size is one, or the empty string when its size is zero. The complexity of the operations 
                is dependent upon the size of the string, thus not all computations should be considered to be working in constant time. <br>
                To represent a string, one should enclose a character sequence in double quotes. For the empty string, provide an empty sequence inside the
                double quotes pair. <br>
                <ul>
                  <b>Examples:</b>
                  <li>String: <code>"abcxyz"</code></li>
                  <li>String also containing non-alphanumerical characters: <code>"a1%x]\0 and &p./?"</code></li>
                  <li>String of size 1 (representation of a single character): <code>"a"</code></li>
                  <li>Empty string: <code>""</code></li>
                </ul>       
              </section>

            </section>

            <section id="compound-types">
              <h4> 2.3.1b Compound data type values </h4>

              <section id="array">
                <h5> 2.3.1b.1 Array</h5>
                An array is a heterogeneous compound data type which can store multiple values in a sequential way with contiguous allocation. The array is limited in size by a <i>MAX_SIZE</i> constant which is initially set to one billion. This can be however altered by the <a href="#option-z">size option</a> providing another maximum.
                The array is <a href="#dynamic-allocation">dynamically allocated</a>, so there is no need to initialize the array beforehand. <br>
                The types of values contained in one array can be both simple or compound. Also, it doesn't have a limit in the nesting depth, so one can enclose
                a unlimited number of values inside the array. The complexities are either linear or constant, depending on the operations. <br>
                To represent an array, one should choose out of the four possible ways to define an iterable data type. The canonical representation is the
                expression based one, as is the most comprehensive.<br>
                <ul>
                  <b>Examples:</b>
                  <li><a href="#expression-representation">Expression based representation</a>: <code>[1, "abc", true, 0.5, [1..5], < "a", "b" >, {0.5, 0.6}, {x -> 2 y -> 3}]</code></li>
                  <li><a href="#interval-representation">Interval based representation</a>: <code>[1..5]</code></li>
                  <li><a href="#filter-representation">Filter specification</a>: <code>[x from [1..5] | x % 2 == 1]</code></li>
                  <li><a href="#map-representation">Map specification</a>: <code>[2 * x | x from [1..5]]</code></li>
                  <li>Empty array: <code>[]</code></li>
                </ul>
              </section>

              <section id="list">
                <h5> 2.3.1b.2 List</h5>
                A list is a heterogeneous compound data type which can store multiple values in a sequential way with discontinuous allocation. The list is limited  in size by a <i>MAX_SIZE</i> constant which is initially set to one billion. This can be however altered by the <a href="#option-z">size option</a> providing another maximum. <br>
                The types of values contained in one list can be both simple or compound. Also, it doesn't have a limit in the nesting depth, so one can enclose
                a unlimited number of values inside the list. The complexities are either linear or constant, depending on the operations. <br>
                To represent a list, one should choose out of the four possible ways to define an iterable data type. The canonical representation is the
                expression based one, as is the most comprehensive. In order to represent the empty list, use the <code>emptyList</code> keyword, or the simple
                <i>open/close</i> syntax.<br> 
                <ul>
                  <b>Examples:</b>
                  <li><a href="#expression-representation">Expression based representation</a>: <code>< 1, "abc", true, 0.5, [1..5], < "a", "b" >, {0.5, 0.6}, {x -> 2 y -> 3} ></code></li>
                  <li><a href="#interval-representation">Interval based representation</a>: <code>< 1..5 ></code></li>
                  <li><a href="#filter-representation">Filter specification</a>: <code>< x from [1..5] | x % 2 == 1 ></code></li>
                  <li><a href="#map-representation">Map specification</a>: <code>< 2 * x | x from [1..5] ></code></li>
                  <li>Empty list: <code>emptyList</code></li>
                  <li>Empty list with <i>open/close</i> syntax: <code><  ></code></li>
                </ul>
              </section>

              <section id="set">
                <h5> 2.3.1b.3 Set</h5>
                A set is a heterogeneous compound data type which can store multiple unique values in a non-sequential way with discontinuous allocation. The set is limited in size by a <i>MAX_SIZE</i> constant which is initially set to one billion. This can be however altered by the <a href="#option-z">size option</a> providing another maximum. <br>
                The types of values contained in one set can be both simple or compound. Also, it doesn't have a limit in the nesting depth, so one can enclose
                a unlimited number of values inside the set. The complexities are either linear or constant, depending on the operations. <br>
                To represent a set, one should choose out of the four possible ways to define an iterable data type. The canonical representation is the
                expression based one, as is the most comprehensive. In order to represent the empty set, use the <code>emptySet</code> keyword, or the simple
                <i>open/close</i> syntax.<br> 
                <ul>
                  <b>Examples:</b>
                  <li><a href="#expression-representation">Expression based representation</a>: <code>{1, "abc", true, 0.5, [1..5], < "a", "b" >, {0.5, 0.6}, {x -> 2 y -> 3}}</code></li>
                  <li><a href="#interval-representation">Interval based representation</a>: <code>{1..5}</code></li>
                  <li><a href="#filter-representation">Filter specification</a>: <code>{x from [1..5] | x % 2 == 1}</code></li>
                  <li><a href="#map-representation">Map specification</a>: <code>{2 * x | x from [1..5]}</code></li>
                  <li>Empty set: <code>emptySet</code></li>
                  <li>Empty set with <i>open/close</i> syntax: <code>{}</code></li>
                </ul>
              </section>

              <section id="structure">
                <h5> 2.3.1b.4 Structure</h5>
                A structure is a heterogeneous compound data type which can store multiple values based on a unique identifier. The structure is limited in size by a  <i>MAX_SIZE</i> constant which is initially set to one billion. This can be however altered by the <a href="#option-z">size option</a> providing another maximum. The structure is <a href="#dynamic-allocation">dynamically allocated</a>, so there is no need to initialize the structure beforehand.<br>
                The types of values contained in one structure can be both simple or compound. Also, it doesn't have a limit in the nesting depth, so one can enclose
                a unlimited number of values inside the structure. <br>
                To represent a structure, one should enclose in curly braces a sequence of space separated <i>pair components</i> which are of form <code>key -> value</code>. An empty structure can't be defined, so it should contain at least one component. <br> 
                <ul>
                  <b>Examples:</b>
                  <li>Simple structure with two components: <code>{x -> 2 y -> 5}</code></li>
                  <li>Complex structure: <code>{a -> 0.5 b -> [1, 2, 3, 4, 5] c -> < "a", "b" > d -> {0.5, 0.6} e -> {x -> 2 y -> 3} x -> 1 y -> "abc" z -> true}</code></li>
                </ul>
              </section>

            </section>

          </section>

          <section id="operators">
            <h3> 2.3.2 Data type operators</h3>

            The majority of the operators are C-like. However there are new sets of operators meant to simplify the operations between certain data types (setwise operators, inclusive operators). In this section, each operator will be explained in terms of behavior, data types and the executionResult of the evaluation. Below it is a table meant to illustrate the priority of operators inside an expression. <br>
            In the table, if the number in the priority column is lower, then the operator will be executed quicker. For example, the conditional operator will be evaluated at the end. The ones which share the same priority, are executed in the order they appear in the expression. In order to suppress this order of evaluation, one can use the round parenthesis (for example: <code>(2 + 3) * 4</code> will executionResult in <code>20</code>).<br>
            To eliminate the confusion, in case of multiple <code>++</code> or <code>--</code> signs, they are parsed from left to right, which means that in an expression like <code>2+++3</code>,
            the evaluation will consider that there is a postfix operator and a plus sign: <code>(2++) + 3</code>. In case of <code>+++2</code>, there is a prefix operator and a unary plus sign: <code>++(+2)</code>.
            <table border = 1>
              <tr><th>Priority</th><th>Operator set</th><th>Operators</th></tr>
              <tr><td>1</td><td>Unary</td><td><code>[], .</code></td></tr>
              <tr><td>2</td><td>Increment / Decrement</td><td><code>++ (post), -- (post)</code></td></tr>
              <tr><td>3</td><td>Unary</td><td><code>+ (unary), - (unary), !</code></td></tr>
              <tr><td>4</td><td>Increment / Decrement</td><td><code>++ (pre), -- (pre)</code></td></tr>
              <tr><td>5</td><td>Arithmetic</td><td><code>*, /, %</code></td></tr>
              <tr><td>6</td><td>Arithmetic</td><td><code>+, -</code></td></tr>
              <tr><td>7</td><td>Bitwise</td><td><code><<, >></code></td></tr>
              <tr><td>8</td><td>Bitwise</td><td><code>&</code></td></tr>
              <tr><td>9</td><td>Bitwise</td><td><code>|, xor</code></td></tr>
              <tr><td>10</td><td>Setwise</td><td><code>U, ^, \</code></td></tr>
              <tr><td>11</td><td>Relational</td><td><code><, >, <=, >=</code></td></tr>
              <tr><td>12</td><td>Relational</td><td><code>==, !=</code></td></tr>
              <tr><td>13</td><td>Inclusive</td><td><code>in</code></td></tr>
              <tr><td>14</td><td>Logical</td><td><code>&&</code></td></tr>
              <tr><td>15</td><td>Logical</td><td><code>||</code></td></tr>
              <tr><td>16</td><td>Conditional</td><td><code>?:</code></td></tr>
            </table>


            <section id="unary-operator">
              <h4> 2.3.2.1 Unary</h4>
              Some unary operators are used in order to suggest the mathematical representations of positive and negative numeric values. Other operators are used for data access (over arrays or structures). The complexity of these operations is constant. The table below explains the behavior of the unary operators when the values <i>a</i> and <i>x</i> are used. Note that in the example below we consider <i>id</i> as a literal identifier.
              <table border = 1>
                <tr><th>Operator</th><th>Representation</th><th>Description</th></tr>
                <tr><td>Positive</td><td><code>+a</code></td><td>Keeps the sign of <i>a</i></td></tr>
                <tr><td>Negative</td><td><code>-a</code></td><td>Changes the sign of <i>a</i></td></tr>
                <tr><td>Not</td><td><code>!a</code></td><td>Changes the truth value of the bool value <i>a</i></td></tr>
                <tr><td>Bracket</td><td><code>a[x]</code></td><td>Access the xth element of <i>a</i></td></tr>
                <tr><td>Dot</td><td><code>a.id</code></td><td>Access the element stored under the <i>id</i> identifier inside <i>a</i></td></tr>
              </table>

              Depending on the operator used and the types of the operands, there can be several return types described in the table below:
              <table border = 1>
                <tr><th>Operator</th><th>Data type 1</th><th>Data type 2</th><th>Return type</th></tr>
                <tr><td>Positive</td><td>integer</td><td></td><td>integer</td></tr>
                <tr><td>Positive</td><td>float</td><td></td><td>float</td></tr>
                <tr><td>Negative</td><td>integer</td><td></td><td>integer</td></tr>
                <tr><td>Negative</td><td>float</td><td></td><td>float</td></tr>
                <tr><td>Not</td><td>boolean</td><td></td><td>boolean</td></tr>
                <tr><td>Bracket</td><td>array</td><td>integer greater or equal to 0 and less than the size of the array</td><td>data type of the element on the xth position</td></tr>
                <tr><td>Dot</td><td>structure</td><td></td><td>data type of the element stored at the specified identifier</td></tr>
              </table>


              <b>Examples:</b>
              <table border = 1>
                <tr><th>Data type</th><th>Positive</th><th>Negative</th><th>Not</th><th>Bracket</th><th>Dot</th></tr>
                <tr><td>Integer</td><td><code>+(-2) is -2</code></td><td><code>-(-2) is 2</code></td><td></td><td></td><td></td></tr>
                <tr><td>Float</td><td><code>-(+2.2) is -2.2</code></td><td><code>+(+2.2) is 2.2</code></td><td></td><td></td><td></td></tr>
                <tr><td>Bool</td><td></td><td></td><td><code>!true is false</code></td><td></td><td></td></tr>
                <tr><td>Array</td><td></td><td></td><td></td><td><code>[1, 2, 3][2] is 3</code></td><td></td></tr>
                <tr><td>Structure</td><td></td><td></td><td></td><td></td><td><code>{x -> 2 y -> 3}.x is 2</code></td></tr>
              </table>
            </section>

            <section id="id-operator">
              <h4> 2.3.2.2 Increment/Decrement</h4>
              There are four types of operators to easily increment or decrement a numeric value. The complexity of these operators is constant. The table below explains the behavior of the operators when a
              numeric value <i>a</i> is used.
              <table border = 1>
                <tr><th>Operator</th><th>Representation</th><th>Description</th></tr>
                <tr><td>Postfix increment</td><td><code>a++</code></td><td>Increases the value of <i>a</i> by 1, but the old value is used in the current expression</td></tr>
                <tr><td>Postfix decrement</td><td><code>a--</code></td><td>Decreseas the value of <i>a</i> by 1, but the old value is used in the current expression</td></tr>
                <tr><td>Prefix increment</td><td><code>++a</code></td><td>Increases the value of <i>a</i> by 1 and the new value is used in the current expression</td></tr>
                <tr><td>Prefix decrement</td><td><code>--a</code></td><td>Decreases the value of <i>a</i> by 1 and the new value is used in the current expression</td></tr>
              </table>

              There is a difference between a postfix and prefix operator:
              <ul>
                <li>The prefix operator changes the value of the operand and the expression continues to work with the updated value.</li>
                <li>The postfix operator changes the value of the operand, but the expression continues to work with its old value.</li>
              </ul>
              Note that only numeric values are valid for this kind of operations. Also, the executionResult always has the same type as the initial value. <br>

              <b>Examples:</b>
              <table border = 1>
                <tr><th>Data type</th><th>Postfix increment</th><th>Postfix decrement</th><th>Prefix increment</th><th>Prefix decrement</th></tr>
                <tr><td>Integer</td><td><code>3++ is 3</code></td><td><code>3-- is 3</code></td><td><code>++3 is 4</code></td><td><code>--3 is 2</code></td></tr>
                <tr><td>Float</td><td><code>3.2++ is 3.2</code></td><td><code>3.2-- is 3.2</code></td><td><code>++3.2 is 4.2</code></td><td><code>--3.2 is 2.2</code></td></tr>
              </table>
            </section>

            <section id="artihmetic-operator">
              <h4> 2.3.2.3 Arithmetic</h4>
              There are two subcategories of arithmetic operators: additive (+, -) and multiplicative (*, /, %). The complexity of those operators are theoretically constant. However, the size of the numbers can matter, so the real complexity is in fact <code>O(N + M)</code> for additive operators, and <code>O(N * M)</code> for the multiplicative operators, where <code>N</code> and <code>M</code> are the number of digits in the operands. <br>
              The table below explains the behavior of the operators when two numeric values <i>a</i> and <i>b</i> are used.
              <table border = 1>
                <tr><th>Operator</th><th>Representation</th><th>Description</th></tr>
                <tr><td>Addition</td><td><code>a + b</code></td><td>Computes the sum of <i>a</i> and <i>b</i></td></tr>
                <tr><td>Subtraction</td><td><code>a - b</code></td><td>Computes the difference between <i>a</i> and <i>b</i></td></tr>
                <tr><td>Multiplication</td><td><code>a * b</code></td><td>Computes the product of <i>a</i> and <i>b</i></td></tr>
                <tr><td>Division</td><td><code>a / b</code></td><td>Computes the division's executionResult of <i>a</i> and <i>b</i></td></tr>
                <tr><td>Mod operator</td><td><code>a % b</code></td><td>Computes the remainder left over when <i>a</i> is divided by <i>b</i></td></tr>
              </table>

              The string data type also has an implementation for the addition operator. The complexity of such operation is <code>O(N) + O(M)</code>, where <code>N</code> and <code>M</code> are the lengths of the string operands. The table below explains the behavior of the additive operator when two strings <i>a</i> and <i>b</i> are used.
              <table border = 1>
                <tr><th>Operator</th><th>Representation</th><th>Description</th></tr>
                <tr><td>Concatenation</td><td><code>a + b</code></td><td>Computes a string representing the concatenation of <i>a</i> and <i>b</i></td></tr>
              </table>

              The results of these first operators are numeric, but the exact resulted data type is sometimes dependent upon the operands. It means that it is relevant what 
              data types <i>a</i> and <i>b</i> have: either integer or float. The table below illustrates of what data type the executionResult is depending on the operator and operands. To be noted than an error is thrown when the mod operator works with a float operand.
              <table border = 1>
                <tr><th>Operator</th><th>Result data type</th><th>Operands data types</th></tr>
                <tr><td>Concatenation</td><td>string</td><td>string, string</td></tr>
                <tr><td>Addition / Subtraction / Multiplication</td><td>integer</td><td>integer, integer</td></tr>
                <tr><td>Addition / Subtraction / Multiplication</td><td>float</td><td>float, integer / integer, float / float, float</td></tr>
                <tr><td>Division</td><td>float</td><td>integer, integer / float, integer / integer, float / float, float</td></tr>
                <tr><td>Mod operator</td><td>integer</td><td>integer, integer</td></tr>
              </table>

              <b>Examples:</b>
              <table border = 1>
                <tr><th>Data type 1</th><th>Data type 2</th><th>Addition / Concatenation</th><th>Subtraction</th><th>Multiplication</th><th>Division</th><th>Mod operator</th></tr>
                <tr><td>Integer</td><td>Integer</td><td><code>3 + 2 is 5</code></td><td><code>3 - 2 is 1</code></td><td><code>3 * 2 is 6</code></td><td><code>3 / 2 is 1</code></td><td><code>3 % 2 is 1</code></td></tr>
                <tr><td>Integer</td><td>Float</td><td><code>3 + 2.2 is 5.2</code></td><td><code>3 - 2.2 is 0.8</code></td><td><code>3 * 2.2 is 6.6</code></td><td><code>3 / 2.2 is 1.3636363636</code></td><td><code></code></td></tr>
                <tr><td>Float</td><td>Integer</td><td><code>3.2 + 2 is 5.2</code></td><td><code>3.2 - 2 is 1.2</code></td><td><code>3.2 * 2 is 6.4</code></td><td><code>3.2 / 2 is 1.6</code></td><td><code></code></td></tr>
                <tr><td>Float</td><td>Float</td><td><code>3.2 + 2.2 is 5.4</code></td><td><code>3.2 - 2.2 is 1.0</code></td><td><code>3.2 * 2.2 is 7.04</code></td><td><code>3.2 / 2.2 is 1.4545454545</code></td><td><code></code></td></tr>
                <tr><td>String</td><td>String</td><td><code>"abc" + "xyz" is "abcxyz"</code></td><td><code></code></td><td><code></code></td><td><code></code></td><td><code></code></td></tr>
              </table>

            </section>

            <section id="bitwise-operator">
              <h4> 2.3.2.4 Bitwise</h4>
              There are five types of operators which work on the bits of integer values. The complexity of these operators is theoretically constant. However, it can be severely influenced by the size of the numbers used. Therefore we can assume that the real complexity is in fact <code>max(log(N), log(M))</code>, where <code>N</code> and <code>M</code> are the operands. The table below explains the behavior of the operators when the
              integer values <i>a</i> and <i>b</i> are used.
              <table border = 1>
                <tr><th>Operator</th><th>Representation</th><th>Description</th></tr>
                <tr><td>Bitwise and</td><td><code>a & b</code></td><td>Computes the executionResult of a bitwise and operation between <i>a</i> and <i>b</i></td></tr>
                <tr><td>Bitwise or</td><td><code>a | b</code></td><td>Computes the executionResult of a bitwise or operation between <i>a</i> and <i>b</i></td></tr>
                <tr><td>Bitwise xor</td><td><code>a xor b</code></td><td>Computes the executionResult of an bitwise xor operation between <i>a</i> and <i>b</i></td></tr>
                <tr><td>Left shift</td><td><code>a << b</code></td><td>Computes the executionResult after a bit shift of <i>a</i> with <i>b</i> bits to the left</td></tr>
                <tr><td>Right shift</td><td><code>a >> b</code></td><td>Computes the executionResult after a bit shift of <i>a</i> with <i>b</i> bits to the right</td></tr>
              </table>

              Note that only integer operands are valid for this kind of operations. Also, the executionResult of these operations is always integer. <br>

              <b>Examples:</b>
              <table border = 1>
                <tr><th>Data type 1</th><th>Data type 2</th><th>Bitwise and</th><th>Bitwise or</th><th>Bitwise xor</th><th>Left shift</th><th>Right shift</th></tr>
                <tr><td>Integer</td><td>Integer</td><td><code>12 & 10 is 8</code></td><td><code>12 | 10 is 14</code></td><td><code>12 xor 10 is 6</code></td><td><code>12 << 10 is 12288</code></td><td><code>12 >> 2 is 3</code></td></tr>
              </table>
            </section>

            <section id="setwise-operator">
              <h4> 2.3.2.5 Setwise</h4>
              There are three types of operators which work exclusively on sets and represent the mathematical set operators. The complexity of these operators is linear, so we can consider the complexity class <code>O(max(|A|, |B|))</code>, where <code>A</code> and <code>B</code> are the set operands. The table below explains the behavior of the operators when the set values <i>a</i> and <i>b</i> are used.
              <table border = 1>
                <tr><th>Operator</th><th>Representation</th><th>Description</th></tr>
                <tr><td>Union</td><td><code>a U b</code></td><td>Computes the union of the represented sets by <i>a</i> and <i>b</i></td></tr>
                <tr><td>Intersection</td><td><code>a ^ b</code></td><td>Computes the intersection of the represented sets by <i>a</i> and <i>b</i></td></tr>
                <tr><td>Difference</td><td><code>a \ b</code></td><td>Computes the difference of the represented sets by <i>a</i> and <i>b</i></td></tr>
              </table>
              Note that the executionResult of these operators is always a set and the operands should be evaluated to set. <br>

              <b>Examples:</b>
              <table border = 1>
                <tr><th>Data type 1</th><th>Data type 2</th><th>Union</th><th>Intersection</th><th>Difference</th></tr>
                <tr><td>Set</td><td>Set</td><td><code>{1, 2, 3} U {2, 3, 4} is {1, 2, 3, 4}</code></td><td><code>{1, 2, 3} ^ {2, 3, 4} is {2, 3}</code></td><td><code>{1, 2, 3} \ {2, 3, 4} is {1}</code></td></tr>
              </table>
            </section>

            <section id="relational-operator">
              <h4> 2.3.2.6 Relational</h4>
              There are two subcategories of relational operators: equality (==, !=) and comparing (<, <=, >=, >). <br>
              There are six types of operators which work on multiple type of values in order to evaluate relational expressions. The complexity of these operators is linear over the size of the operands. For some simple data types, the complexity is <code>O(max(N, M))</code> where <code>N</code> and <code>M</code> are the number of digits in the numeric operands or the length of the string operands. In case of bool types, the complexity is linear. For compound structures, the complexity is the same, but it multiplies with the complexity of checking for the equality of each member. The table below explains the behavior of the operators when the values <i>a</i> and <i>b</i> are used.
              <table border = 1>
                <tr><th>Operator</th><th>Representation</th><th>Description</th></tr>
                <tr><td>Equal</td><td><code>a == b</code></td><td>Checks if <i>a</i> and <i>b</i> have equal values</td></tr>
                <tr><td>Not equal</td><td><code>a != b</code></td><td>Checks if <i>a</i> and <i>b</i> don't have equal values</td></tr>
                <tr><td>Lower than</td><td><code>a < b</code></td><td>Checks if <i>a</i> has a value lower than <i>b</i> </td></tr>
                <tr><td>Lower than or equal</td><td><code>a <= b</code></td><td>Checks if <i>a</i> has a value lower than <i>b</i> or if <i>a</i> and <i>b</i> have equal values</td></tr>
                <tr><td>Greater than or equal</td><td><code>a >= b</code></td><td>Checks if <i>a</i> has a value greater than <i>b</i> or if <i>a</i> and <i>b</i> have equal values</td></tr>
                <tr><td>Greater than</td><td><code>a > b</code></td><td>Checks if <i>a</i> has a value greater than <i>b</i> </td></tr>
              </table>
              These kind of operations have different meanings depending on the data types used for the operands. However, the executionResult is always consistent in data type; these operators always deliver a bool executionResult. The table below describes how these checks are made for each kind of data type.
              <table border = 1>
                <tr><th>Operator</th><th>Result data type</th><th>Operands data types</th><th>Description</th></tr>
                <tr><td>Equality: ==, !=</td><td>bool</td><td>integer, integer / float, integer / integer, float / float, float</td><td>Check if the represented numeric values are equal or not</td></tr>
                <tr><td>Comparing: <, <=, =>, ></td><td>bool</td><td>integer, integer / float, integer / integer, float / float, float</td><td>Check the relation between the represented numeric values</td></tr>
                <tr><td>Equality: ==, !=</td><td>bool</td><td>string, string</td><td>Check if the represented character strings are the same or not</td></tr>
                <tr><td>Comparing: <, <=, =>, ></td><td>bool</td><td>string, string</td><td>Check the lexicographical relation between the represented character strings</td></tr>
                <tr><td>Equality: ==, !=</td><td>bool</td><td>bool, bool</td><td>Check if both bool have the same truth value or not</td></tr>
                <tr><td>Equality: ==, !=</td><td>bool</td><td>array, array</td><td>Check if both arrays have the same size. In case they do, check each pair of elements from same positions in the two arrays to detect if they are equal or not. </td></tr>
                <tr><td>Equality: ==, !=</td><td>bool</td><td>list, list</td><td>Check if both lists have the same size. In case they do, check each pair of elements from same positions in the two lists to detect if they are equal or not. </td></tr>
                <tr><td>Equality: ==, !=</td><td>bool</td><td>set, set</td><td>Check if both sets have the same size. In case they do, check that both coincide with their intersection or not. </td></tr>
                <tr><td>Equality: ==, !=</td><td>bool</td><td>structure, structure</td><td>Check if both structures have the same set of identifiers. In case they do, check if the values associated with each identifier in the structures are equal or not. </td></tr>
              </table>

              <b>Examples:</b>
              <table border = 1>
                <tr><th>Data type 1</th><th>Data type 2</th><th>Equal</th><th>Not equal</th><th>Lower than</th><th>Lower than or equal</th><th>Greater than or equal</th><th>Greater than</th></tr>
                <tr><td>Integer</td><td>Integer</td><td><code>1 == 5 is false</code></td><td><code>1 != 5 is true</code></td><td><code>1 < 5 is true</code></td><td><code>1 <= 5 is true</code></td><td><code>1 >= 5 is false</code></td><td><code>1 > 5 is false</code></td></tr>
                <tr><td>Integer</td><td>Float</td><td><code>1 == 1.0 is true</code></td><td><code>1 != 1.0 is false</code></td><td><code>1 < 1.0 is false</code></td><td><code>1 <= 1.0 is true</code></td><td><code>1 >= 1.0 is true</code></td><td><code>1 > 1.0 is false</code></td></tr>
                <tr><td>Float</td><td>Integer</td><td><code>1.2 == 1 is false</code></td><td><code>1.2 != 1 is true</code></td><td><code>1.2 < 1 is false</code></td><td><code>1.2 <= 1 is false</code></td><td><code>1.2 >= 1 is true</code></td><td><code>1.2 > 1 is true</code></td></tr>
                <tr><td>Float</td><td>Float</td><td><code>1.2 == 1.3 is false</code></td><td><code>1.2 != 1.3 is true</code></td><td><code>1.2 < 1.3 is true</code></td><td><code>1.2 <= 1.3 is true</code></td><td><code>1.2 >= 1.3 is false</code></td><td><code>1.2 > 1.3 is false</code></td></tr>
                <tr><td>String</td><td>String</td><td><code>"abc" == "xyz" is false</code></td><td><code>"abc" != "xyz" is true</code></td><td><code>"abc" < "xyz" is true</code></td><td><code>"abc" <= "xyz" is true</code></td><td><code>"abc" >= "xyz" is false</code></td><td><code>"abc" > "xyz" is false</code></td></tr>
                <tr><td>Bool</td><td>Bool</td><td><code>true == false is false</code></td><td><code>true != false is true</code></td><td><code></code></td><td><code></code></td><td><code></code></td><td><code></code></td></tr>
                <tr><td>Array</td><td>Array</td><td><code>[1, "abc"] == [1, "abc"] is true</code></td><td><code>[1, "abc"] != [1, "abc"] is false</code></td><td><code></code></td><td><code></code></td><td><code></code></td><td><code></code></td></tr>
                <tr><td>List</td><td>List</td><td><code><1, "abc"> == <1.1, "abc"> is false</code></td><td><code><1, "abc"> != <1.1, "abc"> is true</code></td><td><code></code></td><td><code></code></td><td><code></code></td><td><code></code></td></tr>
                <tr><td>Set</td><td>Set</td><td><code>{1, "abc"} == {1, "abc"} is true</code></td><td><code>{1, "abc"} != {1, "abc"} is false</code></td><td><code></code></td><td><code></code></td><td><code></code></td><td><code></code></td></tr>
                <tr><td>Structure</td><td>Structure</td><td><code>{x->1.1 y->"abc"} == {x->"abc" y->1.1} is false</code></td><td><code>{x->1.1 y->"abc"} != {x->"abc" y->1.1} is true</code></td><td><code></code></td><td><code></code></td><td><code></code></td><td><code></code></td></tr>
              </table>

            </section>

            <section id="inclusive-operator">
              <h4> 2.3.2.7 Inclusive</h4>
              The inclusive operator is used in order to detect if a specific element is contained by an iterable data type. The complexity is linear as each element in the iterable structure is checked against the probe, so we can consider <code>O(N * X)</code>, where <code>N</code> is the size of the structure and <code>X</code> is the complexity to test equality. The table below explains the behavior of the inclusive operator when the value <i>a</i> and iterable value <i>b</i> are used.
              <table border = 1>
                <tr><th>Operator</th><th>Representation</th><th>Description</th></tr>
                <tr><td>Inclusive</td><td><code>a in b</code></td><td>Checks if <i>a</i> is contained in <i>b</i> or not.</td></tr>
              </table>
              Note that the inclusive operator always returns a bool value. Also, <i>b</i> should always evaluate to an iterable data type. In order to check the inclusion, the equal operator is used. <br>

              <b>Examples:</b>
              <table border = 1>
                <tr><th>Data type 1</th><th>In array</th><th>In list</th><th>In set</th></tr>
                <tr><td>Integer</td><td><code>2 in [1, 2, 3] is true</code></td><td><code>4 in <1, 2, 3> is false</code></td><td><code>4 in {1, 2, 3} is false</code></td></tr>
                <tr><td>Float</td><td><code>2.2 in [1, 2, 3] is false</code></td><td><code>2.0 in <1, 2, 3> is true</code></td><td><code>2.0 in {1, 2, 3} is true</code></td></tr>
                <tr><td>Bool</td><td><code>true in [false] is false</code></td><td><code>true in < true, false > is true</code></td><td><code>true in {true, false} is true</code></td></tr>
                <tr><td>String</td><td><code>"abc" in ["abc", "xyz"] is true</code></td><td><code>"abc" in <"Abc", "xyz"> is false</code></td><td><code>"abc" in {"Abc", "xyz"} is false</code></td></tr>
                <tr><td>Array</td><td><code>[1, 2] in [1, [1, 2.2], 3] is false</code></td><td><code>[1, 2] in <1, [1, 2.0], 3> is true</code></td><td><code>[1, 2] in {1, [1, 2], 3} is true</code></td></tr>
                <tr><td>List</td><td><code><1, 2> in [1, <1, 2.2>, 3] is false</code></td><td><code><1, 2> in <1, <1, 2.0>, 3> is true</code></td><td><code><1, 2> in {1, <1, 2>, 3} is true</code></td></tr>
                <tr><td>Set</td><td><code>{1, 2} in [1, {1, 2.2}, 3] is false</code></td><td><code>{1, 2} in <1, {1, 2.0}, 3> is true</code></td><td><code>{1, 2} in {1, {1, 2}, 3} is true</code></td></tr>
                <tr><td>Structure</td><td><code>{x->2 y->3} in [1, {x->2.2 y->3}, 3] is false</code></td><td><code>{x->2 y->3} in <1, {x->2.0 y->3}, 3> is true</code></td><td><code>{x->2 y->3} in {1, {x->2 y->3}, 3} is true</code></td></tr>
              </table>
            </section>

            <section id="logical-operator">
              <h4> 2.3.2.8 Logical</h4>
              There are three types of operators which work on the bool values in order to evaluate logical expressions. The complexity for these operands is constant. The table below explains the behavior of the operators when the
              bool values <i>a</i> and <i>b</i> are used.
              <table border = 1>
                <tr><th>Operator</th><th>Representation</th><th>Description</th></tr>
                <tr><td>Logical and</td><td><code>a && b</code></td><td>Computes the executionResult of a logical and operation between <i>a</i> and <i>b</i></td></tr>
                <tr><td>Logical or</td><td><code>a || b</code></td><td>Computes the executionResult of a logical or operation between <i>a</i> and <i>b</i></td></tr>
              </table>
              Note that only bool values are valid for this kind of operations. Also, the executionResult of these operations is always bool. <br>

              <b>Examples:</b>
              <table border = 1>
                <tr><th>Data type 1</th><th>Data type 2</th><th>Logical and</th><th>Logical or</th></tr>
                <tr><td>Bool</td><td>Bool</td><td><code>true && false is false</code></td><td><code>true || false is true</code></td></tr>
              </table>
            </section>

            <section id="conditional-operator">
              <h4> 2.3.2.9 Conditional</h4>
              The conditional operator is used as an inline conditional statement and is the only ternary operator by now. The complexity for this operator is constant. The table below explains the behavior of the operator when the bool value <i>a</i> and other values <i>b</i> and <i>c</i> are used.
              <table border = 1>
                <tr><th>Operator</th><th>Representation</th><th>Description</th></tr>
                <tr><td>Conditional</td><td><code>a ? b : c</code></td><td>Evaluates to <i>b</i> only if <i>a</i> is true, otherwise it evaluates to <i>c</i></td></tr>
              </table>
              Note that <i>a</i> should always evaluate to a bool value, while there is no restriction over the data types of <i>b</i> and <i>c</i>. The executionResult is either <i>b</i> or <i>c</i>.<br>

              <b>Examples:</b>
              <table border = 1>
                <tr><th>Data type 1</th><th>Data type 2</th><th>Data type 3</th><th>Conditional</th></tr>
                <tr><td>Bool</td><td>Integer</td><td>String</td><td><code>true ? 5 : "abc" is 5</code></td></tr>
                <tr><td>Bool</td><td>Float</td><td>Bool</td><td><code>false ? 2.5 : true is true</code></td></tr>
                <tr><td>Bool</td><td>Array</td><td>List</td><td><code>true ? [1, 2, 3] : <4, 5, 6> is [1, 2, 3]</code></td></tr>
                <tr><td>Bool</td><td>Set</td><td>Structure</td><td><code>false ? {1, 2, 3} : {x->2 y->3} is {x->2 y->3}</code></td></tr>
              </table>
            </section>


          </section>

          <section id="builtin-functions">
            <h3> 2.3.3 Builtin Functions</h3>
            The builtin functions have the highest priority as long as they can be seen as predicates. An important aspect is that there can't be custom defined functions with the same name as the builtin functions.

            <section id="mathematical-functions">
              <h4> 2.3.3.1 Mathematical</h4>
              There are several mathematical builtin functions. All of them work with numeric types and also evaluate to numeric values. The table below explains the behavior of the mathematical builtin functions when the numeric values <i>a</i> and <i>b</i> are used.
              <table border = 1>
                <tr><th>Builtin Function</th><th>Representation</th><th>Description</th></tr>
                <tr><td>Sin</td><td><code>sin(a)</code></td><td>Returns the sine of <i>a</i>, where <i>a</i> is a numeric value representing radian units</td></tr>
                <tr><td>Cos</td><td><code>cos(a)</code></td><td>Returns the cosine of <i>a</i>, where <i>a</i> is a numeric value representing radian units</td></tr>
                <tr><td>Tan</td><td><code>tan(a)</code></td><td>Returns the tangent of <i>a</i>, where <i>a</i> is a numeric value representing radian units</td></tr>
                <tr><td>Asin</td><td><code>asin(a)</code></td><td>Returns the inverse sine of <i>a</i>, where <i>a</i> is a numeric value which should be in <i>[-1, 1]</i> interval</td></tr>
                <tr><td>Acos</td><td><code>acos(a)</code></td><td>Returns the inverse cosine of <i>a</i>, where <i>a</i> is a numeric value which should be in <i>[-1, 1]</i> interval</td></tr>
                <tr><td>Atan</td><td><code>atan(a)</code></td><td>Returns the inverse tangent of <i>a</i>, where <i>a</i> is a numeric value which should be in <i>[-1, 1]</i> interval</td></tr>
                <tr><td>Log</td><td><code>log(a)</code></td><td>Returns the natural logarithm of <i>a</i>, where <i>a</i> is a positive numeric value</td></tr>
                <tr><td>Pow</td><td><code>pow(a, b)</code></td><td>Returns <i>a</i> power <i>b</i></td></tr>
                <tr><td>Sqrt</td><td><code>sqrt(a)</code></td><td>Returns the square root of <i>a</i> </td></tr>
                <tr><td>Pi</td><td><code>pi()</code></td><td>Returns the value of <i>π</i> </td></tr>
                <tr><td>Abs</td><td><code>abs(a)</code></td><td>Returns the absolute value of <i>a</i> </td></tr>
              </table>
              Note that all the functions above are working with numeric type values: integer or float. The executionResult of these functions are all float, no matter the operands' types. In the examples section we presume that the precision was set to 3 decimals after the floating point.<br>

              <b>Examples:</b>
              <table border = 1>
                <tr><th>Operand 1</th><th>Operand 2</th><th>Sin</th><th>Cos</th><th>Tan</th><th>Asin</th><th>Acos</th><th>Atan</th><th>Log</th><th>Pow</th><th>Sqrt</th><th>Pi</th><th>Abs</th></tr>
                <tr><td>Integer</td><td>Integer</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td><code>pow(2, 3) is 8.0</code></td><td></td><td></td><td></td></tr>
                <tr><td>Integer</td><td>Float</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td><code>pow(2, 3.2) is 11.313</code></td><td></td><td></td><td></td></tr>
                <tr><td>Float</td><td>Integer</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td><code>pow(2.5, 3) is 15.625</code></td><td></td><td></td><td></td></tr>
                <tr><td>Float</td><td>Float</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td><code>pow(2.5, 3.5) is 24.705</code></td><td></td><td></td><td></td></tr>
                <tr><td>Integer</td><td></td><td><code>sin(2) is 0.909</code></td><td><code>cos(2) is -0.412</code></td><td><code>tan(2) is -2.185</code></td><td><code>asin(1) is 1.570</code></td><td><code>acos(-1) is 3.141</code></td><td><code>atan(1) is 0.785</code></td><td><code>log(2) is 0.693</code></td><td></td><td><code>sqrt(2) is 1.414</code></td><td></td><td><code>abs(2) is 2.0</code></td></tr>
                <tr><td>Float</td><td></td><td><code>sin(-2.5) is -0.598</code></td><td><code>cos(-2.5) is -0.801</code></td><td><code>tan(-2.5) is 0.747</code></td><td><code>asin(-0.5) is -0.523</code></td><td><code>acos(-0.5) is 2.094</code></td><td><code>atan(-0.5) is -0.463</code></td><td><code>log(0.5) is -0.693</code></td><td></td><td><code>sqrt(0.5) is 0.707</code></td><td></td><td><code>abs(-0.5) is 0.5</code></td></tr>
                <tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td><code>pi() is 3.141</code></td><td></td></tr>
              </table>

            </section>

            <section id="conversion-functions">
              <h4> 2.3.3.2 Conversion</h4>
              There are only two conversion builtin functions while are used in order to change the data type of one numerical value from float to integer or from integer to float. The table below explains the behavior of the conversion builtin functions when the numeric value <i>a</i> is used.

              <table border = 1>
                <tr><th>Builtin Function</th><th>Representation</th><th>Description</th></tr>
                <tr><td>Int</td><td><code>int(a)</code></td><td>Converts the numeric value of <i>a</i> to an integer representation. </td></tr>
                <tr><td>Float</td><td><code>float(a)</code></td><td>Converts the numeric value of <i>a</i> to a float representation. </td></tr>
              </table>
              Note that the int function can produce data loss if <i>a</i> has a non-zero fractional part. Also, the only data type allowed for <i>a</i> is either float or integer. <br>

              <b>Examples:</b>
              <table border = 1>
                <tr><th>Data type</th><th>Int</th><th>Float</th></tr>
                <tr><td>Integer</td><td><code>int(2) is 2</code></td><td><code>float(2) is 2.0</code></td></tr>
                <tr><td>Float</td><td><code>int(2.5) is 2</code></td><td><code>float(2.5) is 2.5</code></td></tr>
              </table>              

            </section>

            <section id="string-functions">
              <h4> 2.3.3.3 String based</h4>
              There is only one string based function which is used in order to determine the size of a string. The table below explains the behavior of the string based builtin function when the string value <i>a</i> is used.

              <table border = 1>
                <tr><th>Builtin Function</th><th>Representation</th><th>Description</th></tr>
                <tr><td>Len</td><td><code>len(a)</code></td><td>Returns the size of the string <i>a</i> in number of characters. </td></tr>
              </table>
              Note that the len builtin function returns a positive integer and the only valid operand data type is string. <br>

              <b>Examples:</b>
              <table border = 1>
                <tr><th>Data type</th><th>Len</th></tr>
                <tr><td>String</td><td><code>len("abc") is 3</code></td></tr>
              </table>  
            </section>

            <section id="io-functions">
              <h4> 2.3.3.4 IO</h4>
              There is only one IO function which is used in order to print to the terminal a provided value. The table below explains the behavior of the IO builtin function when the value <i>a</i> is used.
              <table border = 1>
                <tr><th>Builtin Function</th><th>Representation</th><th>Description</th></tr>
                <tr><td>Print</td><td><code>print(a)</code></td><td>Writes to the terminal a string which represents the value <i>a</i> </td></tr>
              </table>
              Note than any kind of value is valid for the print function as all data types do have a string representation. This can't be used inside an expression as it doesn't return any value. It can however be used as a standalone function call.<br>
              <b>Examples:</b>
              <table border = 1>
                <tr><th>Data type</th><th>Print</th></tr>
                <tr><td>Integer</td><td><code>print(2) prints 2</code></td></tr>
                <tr><td>Float</td><td><code>print(2.5) prints 2.5</code></td></tr>
                <tr><td>Bool</td><td><code>print(true) prints true</code></td></tr>
                <tr><td>String</td><td><code>print("abc") prints true</code></td></tr>
                <tr><td>Array</td><td><code>print([1, 2, 3]) prints [1, 2, 3]</code></td></tr>
                <tr><td>List</td><td><code>print(< 1, 2, 3 >) prints < 1, 2, 3 ></code></td></tr>
                <tr><td>Set</td><td><code>print({1, 2, 3}) prints {1, 2, 3}</code></td></tr>
                <tr><td>Structure</td><td><code>print({x -> 2 y -> 5}) prints {x -> 2 y -> 5}</code></td></tr>
              </table>  
            </section>

            <section id="probabilistic-functions">
              <h4> 2.3.3.5 Probabilistic</h4>
              There is only one probabilistic function which is used to randomly generate an integer value using an uniform distribution. The table below explains the behavior of the probabilistic builtin function when the integer value <i>a</i> is used.
              <table border = 1>
                <tr><th>Builtin Function</th><th>Representation</th><th>Description</th></tr>
                <tr><td>Random</td><td><code>random(a)</code></td><td>Returns a random integer number which is strictly less than <i>a</i> and greater than or equal to 0 </td></tr>
              </table>
              Note than only integer values are valid for the operand. Also, the use of this function triggers an probabilistic execution. <br>

              <b>Examples:</b>
              <table border = 1>
                <tr><th>Data type</th><th>Print</th></tr>
                <tr><td>Integer</td><td><code>random(4) returns a value in {0, 1, 2, 3} with uniform probability</code></td></tr>
              </table>  
            </section>

            <section id="structural-functions">
              <h4> 2.3.3.6 Structural</h4>
              There is only one structural function which is used to compute a set containing a single element. The table below explains the behavior of the structural builtin function when the value <i>a</i> is used.
              <table border = 1>
                <tr><th>Builtin Function</th><th>Representation</th><th>Description</th></tr>
                <tr><td>SingletonSet</td><td><code>singletonSet(a)</code></td><td>Returns a set containing a single element <i>a</i> </td></tr>
              </table>
              Note that this function always return a set and the operand data type is irrelevant. This can also be reproduced with a simpler syntax <code>{a}</code>, where a is the only element in the set.<br>

              <b>Examples:</b>
              <table border = 1>
                <tr><th>Data type</th><th>SingletonSet</th></tr>
                <tr><td>Integer</td><td><code>singletonSet(2) is {2}</code></td></tr>
                <tr><td>Float</td><td><code>singletonSet(2.5) is {2.5}</code></td></tr>
                <tr><td>Bool</td><td><code>singletonSet(true) is {true}</code></td></tr>
                <tr><td>String</td><td><code>singletonSet("abc") is {"abc"}</code></td></tr>
                <tr><td>Array</td><td><code>singletonSet([1, 2, 3]) is {[1, 2, 3]}</code></td></tr>
                <tr><td>List</td><td><code>singletonSet(<1, 2, 3>) is {<1, 2, 3>}</code></td></tr>
                <tr><td>Set</td><td><code>singletonSet({1, 2, 3}) is {{1, 2, 3}}</code></td></tr>
                <tr><td>Structure</td><td><code>singletonSet({x -> 2 y -> 3}) is {{x -> 2 y -> 3}}</code></td></tr>
              </table> 
            </section>

          </section>

          <section id="builtin-methods">
            <h3> 2.3.4 Builtin Methods </h3>
            The builtin methods have a high priority; in fact they have the same priority as the dot operator and the bracket operator. However, the order of these operators is relevant in execution. Also, the parenthesis can override these rules.

            In order to call a builtin method, there is a special syntax which should be used.
            <table border = 1>
              <tr><th>Syntax for method-call</th></tr>
              <tr><td><code>reference.method-name(method-parameters)</code></td></tr>
            </table> 

            <b>Reference:</b> <br>
            The reference usually has to point to a specific location which should be already created (the dynamic allocation doesn't activate in this scenario). The most basic type of reference is an identifier, which already exists or will be automatically created in the environment. A more complex reference is composed out of an identifier and a sequence of brackets and dot operators to indicate a specific location inside a compound data type value. <br>
            <b>Method-name:</b> <br>
            The methods are all builtin, meaning that the method-name should be chosen from a predefined list of names, depending upon the desired behavior. Custom methods are not supported at the moment. <br>
            <b>Method-parameters:</b> <br>
            The method-parameters component is a list of comma separated expressions. The number of expressions should match the number of parameters requested by the builtin method. Also, depending on the method, the evaluation data type values should match the parameters constraints (ex: <code>at</code> method works only with specific integers) <br>


            <section id="query-builtin-methods">
              <h4> 2.3.4.1 Query</h4>
              There are several query methods which are used in order to get information about some values (strings or compound). They do not modify the value. The table below explains the behavior of the query builtin methods when the target value <i>a</i>, the integer value <i>x</i> and the string value <i>y</i> are used.
              <table border = 1>
                <tr><th>Builtin Method</th><th>Representation</th><th>Description</th></tr>
                <tr><td>At</td><td><code>a.at(x)</code></td><td>Evaluates to the element on the xth position in the compound value <i>a</i>. <i>x</i> should be greater than 0 and less than the size </td></tr>
                <tr><td>Size</td><td><code>a.size()</code></td><td>Computes the size of <i>a</i> in constant time</td></tr>
                <tr><td>TopBack</td><td><code>a.topBack()</code></td><td>Evaluates to the last element in the value <i>a</i> </td></tr>
                <tr><td>TopFront</td><td><code>a.topFront()</code></td><td>Evaluates to the first element in the value <i>a</i> </td></tr>
                <tr><td>Split</td><td><code>a.split()</code></td><td>Returns an array of characters resulted after spliting the string <i>a</i> </td></tr>
                <tr><td>Split with regex</td><td><code>a.split(y)</code></td><td>Returns an array of strings resulted after splitting the string <i>a</i> with a regular expression <i>y</i> </td></tr>
              </table>

              Note that all these methods are returning different kind of data types (depending on the operand and method). Also, not all compound data types are eligible for all these methods. The table below illustrates these aspects.
              <table border = 1>
                <tr><th>Builtin Method</th><th>Data type</th><th>Return</th><th>Return Type</th></tr>
                <tr><td>At</td><td>string, array or list</td><td>the element on the xth position in the value</td><td>the data type of the element at the xth position</td></tr>
                <tr><td>Size</td><td>array, list or set</td><td>the number of values nested in the value</td><td>integer</td></tr>
                <tr><td>Size</td><td>string</td><td>the number of characters in the string</td><td>integer</td></tr>
                <tr><td>TopBack</td><td>list</td><td>the last element in the value</td><td>the data type of the last element in the value</td></tr>
                <tr><td>TopFront</td><td>list</td><td>the first element in the value</td><td>the data type of the first element in the value</td></tr>
                <tr><td>TopFront</td><td>list</td><td>the first element in the value</td><td>the data type of the first element in the value</td></tr>
                <tr><td>Split</td><td>string</td><td>the characters which can be found in the string</td><td>an array of characters</td></tr>
                <tr><td>Split with regex</td><td>string</td><td>the strings resulted after splitting the string with a regex</td><td>an array of strings</td></tr>
              </table>
              For the at method, one should provide a valid integer value <i>x</i>. <br>

              <b>Examples:</b>
              <table border = 1>
                <tr><th>Data type</th><th>At</th><th>Size</th><th>TopBack</th><th>TopFront</th><th>Split</th><th>Split with regex</th></tr>
                <tr><td>String</td><td><code>"abc".at(2) is "c"</code></td><td><code>"abc".size() is 3</code></td><td></td><td></td><td><code>"abc".split() is ["a", "b", "c"]</code></td><td><code>"a c".split(" ") is ["a", "c"]</code></td></tr>
                <tr><td>Array</td><td><code>[5, 7, 10].at(1) is 7</code></td><td><code>[5, 7, 10].size() is 3</code></td><td></td><td></td><td></td><td></td></tr>
                <tr><td>List</td><td><code><5, 7, 10>.at(1) is 7</code></td><td><code><5, 7, 10>.size() is 3</code></td><td><code><5, 7, 10>.topBack() is 10</code></td><td><code><5, 7, 10>.topFront() is 6</code></td><td></td><td></td></tr>
                <tr><td>Set</td><td></td><td><code>{5, 7, 10}.size() is 3</code></td><td></td><td></td><td></td><td></td></tr>
              </table> 

            </section>

            <section id="update-builtin-methods">
              <h4> 2.3.4.2 Update</h4>
              There are several update methods which are used in order to modify some values (string or compound). They do modify the value and return a reference to the modified object. The table below explains the behavior of the query builtin methods when the target value <i>a</i> and values <i>x</i>, <i>y</i> are used.
              
              <table border = 1>
                <tr><th>Builtin Method</th><th>Representation</th><th>Description</th></tr>
                <tr><td>Non-Sequential Insert</td><td><code>a.insert(x)</code></td><td>Insert value <i>x</i> into a non-sequential value <i>a</i> </td></tr>
                <tr><td>Sequential Insert</td><td><code>a.insert(x, y)</code></td><td>Insert value <i>y</i> into a sequential value <i>a</i> at position <i>x</i> </td></tr>
                <tr><td>PopBack</td><td><code>a.popBack()</code></td><td>Remove the last element in a sequential value <i>a</i> </td></tr>
                <tr><td>PopFront</td><td><code>a.popFront()</code></td><td>Remove the first element in a sequential value <i>a</i> </td></tr>
                <tr><td>PushBack</td><td><code>a.pushBack(x)</code></td><td>Add the value <i>x</i> as the last element of a sequential value <i>a</i> </td></tr>
                <tr><td>PushFront</td><td><code>a.pushFront(x)</code></td><td>Add the value <i>x</i> as the first element of a sequential value <i>a</i> </td></tr>
                <tr><td>Remove</td><td><code>a.remove(x)</code></td><td>Removes value <i>x</i> from a non-sequential value <i>a</i> </td></tr>
                <tr><td>RemoveAt</td><td><code>a.removeAt(x)</code></td><td>Removes the element at position <i>x</i> from a sequential value <i>a</i> </td></tr>
                <tr><td>RemoveAllEqTo</td><td><code>a.removeAllEqTo(x)</code></td><td>Removes all elements equal to <i>x</i> from value <i>a</i> </td></tr>
                <tr><td>Update</td><td><code>a.update(x, y)</code></td><td>Updates the value from position <i>x</i> to value <i>y</i> inside the sequential value <i>a</i> </td></tr>
              </table>

              Note that there is a distinction between the sequential (array, list) values and non-sequential values (set). Also, there are restrictions on the values of <i>x</i> and <i>y</i>. All of these are described in the table below.
              
              <table border = 1>
                <tr><th>Builtin Method</th><th>Data type</th><th>First parameter</th><th>Second parameter</th></tr>
                <tr><td>Non-Sequential Insert</td><td>set</td><td>Any kind of value</td><td></td></tr>
                <tr><td>Sequential Insert</td><td>array, list</td><td>An integer greater or equal to 0 and less or equal to the size of the target value</td><td>Any kind of value</td></tr>
                <tr><td>PopBack</td><td>array, list</td><td></td><td></td></tr>
                <tr><td>PopFront</td><td>array, list</td><td></td><td></td></tr>
                <tr><td>PushBack</td><td>array, list</td><td>Any kind of value</td><td></td></tr>
                <tr><td>PushFront</td><td>array, list</td><td>Any kind of value</td><td></td></tr>
                <tr><td>Remove</td><td>set</td><td>Any kind of value</td><td></td></tr>
                <tr><td>RemoveAt</td><td>array, list</td><td>An integer greater or equal to 0 and less than the size of the target value</td><td></td></tr>
                <tr><td>RemoveAllEqTo</td><td>array, list</td><td>Any kind of value</td><td></td></tr>
                <tr><td>Update</td><td>array, list</td><td>An integer greater or equal to 0 and less than the size of the target value</td><td>Any kind of value</td></tr>
              </table>

              Note that all these methods return the modified value (which is the same as the target value used). This means that multiple methods can be chained: <code>a.pushBack(x).popBack()</code> is a valid expression. <br>

              <b>Examples:</b>
              <table border = 1>
                <tr><th>Method</th><th>Array</th><th>List</th><th>Set</th></tr>
                <tr><td>Non-Sequential Insert</td><td><code></code></td><td><code></code></td><td><code>{1, 2, 3}.insert(4) is {1, 2, 3, 4}</code></td></tr>
                <tr><td>Insert</td><td><code>[1, 2, 3].insert(1, 4) is [1, 4, 2, 3]</code></td><td><code><1, 2, 3>.insert(1, 4) is <1, 4, 2, 3></code></td><td><code></code></td></tr>
                <tr><td>PopBack</td><td><code>[1, 2, 3].popBack() is [1, 2]</code></td><td><code><1, 2, 3>.popBack() is <1, 2></code></td><td><code></code></td></tr>
                <tr><td>PopFront</td><td><code>[1, 2, 3].popFront() is [2, 3]</code></td><td><code><1, 2, 3>.popFront() is <2, 3></code></td><td><code></code></td></tr>
                <tr><td>PushBack</td><td><code>[1, 2, 3].pushBack(4) is [1, 2, 3, 4]</code></td><td><code><1, 2, 3>.pushBack(4) is <1, 2, 3, 4></code></td><td><code></code></td></tr>
                <tr><td>PushFront</td><td><code>[1, 2, 3].pushFront(4) is [4, 1, 2, 3]</code></td><td><code><1, 2, 3>.pushFront(4) is <4, 1, 2, 3></code></td><td><code></code></td></tr>
                <tr><td>Remove</td><td><code></code></td><td><code></code></td><td><code>{1, 2, 3}.remove(2) is {1, 3}</code></td></tr>
                <tr><td>RemoveAt</td><td><code>[1, 2, 3].removeAt(1) is [1, 3]</code></td><td><code><1, 2, 3>.removeAt(1) is <1, 3></code></td><td><code></code></td></tr>
                <tr><td>RemoveAllEqTo</td><td><code>[1, 2, 1].removeAllEqTo(1) is [2]</code></td><td><code><1, 2, 1>.removeAllEqTo(1) is <2></code></td><td><code></code></td></tr>
                <tr><td>Update</td><td><code>[1, 2, 3].update(1, 4) is [1, 4, 3]</code></td><td><code><1, 2, 3>.update(1, 4) is <1, 4, 3></code></td><td><code></code></td></tr>
              </table> 
              
            </section>

          </section>

        </section>

        <section id="declarations_initializations">
          <h2> 2.4 Declarations and Initializations </h2>
          
          <section id="default-initialization">
            <h3> 2.4.1 Default initialization values </h3>

            In the context of using Alk, the variables should not be declared, so there is no concept alike the default initialization. This is due to the fact that, Alk does not create pristine variables which do have a default value (or a garbage value). The variables created are in fact spawned because they are needed into an assign, so no intermediary value is used. <br>

            However, there is a similar concept to the default values present in Alk. The idea of unknown value is used when dealing with non-returning functions inside expressions or empty spaces inside dynamically allocated arrays. The next section will show that this unknown value is.

          </section>

          <section id="dynamic-allocation">
            <h3> 2.4.2 Dynamic allocation </h3>

            There is an important feature of Alk regarding the allocation. Due to the fact that one wants to use uninitialized compound data values, Alk offers support for dynamically allocation arrays/structures such that the references used do make sense and point to a valid memory address.<br>

            For this matter, imagine the following example: <code>a[2].x = 5;</code>. Note that this is the only instruction in the parsed algorithm. As variables should not be declared, this statement should work without any other specifications. For this job, Alk will automatically assign to the variable <code>a</code> an array data type value, which will have the size of 3, in order to allow the use of the bracket operator. Furthermore, at the index 2, a structure should be allocated in order to match the dot operator. Finally, after those two enclosed values were created, the assignment will work as Alk will automatically allocate a component with id <code>x</code> which will be assigned to 5.

            However, the process above has a practical flow: what happens to the extra allocated space? In the example above, what values will be assigned to <code>a[0]</code> and <code>a[1]</code>. For this matter, Alk uses a special kind of representation, the <code>?</code> character which will symbolize that the specified additional space is unusable in the current state. So any usage of <code>a[0]</code> or <code>a[1]</code> will executionResult in an error. However, one can assign new values to these references in order to properly access them afterwards. <br>

            <b>Examples:</b>
            <table border="1">
              <tr><th>Assignment statement</th><th>Final configuration</th></tr>
              <tr><td><code>a[2][3].x.y[1].z = 2;</code></td><td><code>a |-> [?, ?, [?, ?, ?, {x -> {y -> [?, {z -> 2}]}}]]</code></td></tr>
              <tr><td><code>a[0][1][2][3][4] = 2;</code></td><td><code>a |-> [[?, [?, ?, [?, ?, ?, [?, ?, ?, ?, 2]]]]]</code></td></tr>
              <tr><td><code>a.x.y.z = 2;</code></td><td><code>a |-> {x -> {y -> {z -> 2}}}</code></td></tr>
            </table>

          </section>


          <section id="iterable-data-types">
            <h3>2.4.3 Iterable data types definition</h3>

            <section id="expression-representation">
              <h4> 2.4.3.1 Expression based definition </h4>
              The expression based definitions are the basic way to define one iterable data type value. It allows one to enclose between specific characters, a series of comma separated expressions. Each expression will be evaluated and the executionResult will be considered to be contained by the specified data type in the order provided. Note that a set can change the order of the elements. <br>

              <b>Examples:</b>
              <table border="1">
                <tr><th>Representation</th><th>Final configuration</th></tr>
                <tr><td><code>a = [1+1, {1, 2, 3} U {2, 3, 4}, 1.2/2];</code></td><td><code>a |-> [2, {1, 2, 3, 4}, 0.6]</code></td></tr>
                <tr><td><code>a = <1+1, {1, 2, 3} U {2, 3, 4}, 1.2/2>;</code></td><td><code>a |-> <2, {1, 2, 3, 4}, 0.6></code></td></tr>
                <tr><td><code>a = {1+1, {1, 2, 3} U {2, 3, 4}, 1.2/2};</code></td><td><code>a |-> {0.6, 2, {1, 2, 3, 4}}</code></td></tr>
              </table>

            </section>

            <section id="interval-representation">
              <h4> 2.4.3.2 Interval based definition </h4>
              The interval based definition provides a way to easily instantiate an iterable data type value with a sequence of integers contained in a specified interval. The order of the elements will be ascending. <br>

              <b>Examples:</b>
              <table border="1">
                <tr><th>Representation</th><th>Final configuration</th></tr>
                <tr><td><code>a = [1..5];</code></td><td><code>a |-> [1, 2, 3, 4, 5]</code></td></tr>
                <tr><td><code>a = <1..5>;</code></td><td><code>a |-> <1, 2, 3, 4, 5></code></td></tr>
                <tr><td><code>a = {1..5};</code></td><td><code>a |-> {1, 2, 3, 4, 5}</code></td></tr>
              </table>

            </section>

            <section id="filter-representation">
              <h4> 2.4.3.3 Filter specification based definition </h4>
              This type of representation is well suited in scenarios in which one wants to apply a certain filtering over the elements of a container. The filtering specification has a boolean expression provided which will be run using each element in a source value in order to detect if the chosen element shall pass the filtering or not. This depends on the executionResult of the boolean expression. <br>

              <b>Examples:</b>
              <table border="1">
                <tr><th>Representation</th><th>Final configuration</th></tr>
                <tr><td><code>a = [x from [1..5] | x % 2 == 0];</code></td><td><code>a |-> [2, 4]</code></td></tr>
                <tr><td><code>a = < x from [1..5] | x % 2 == 1 >;</code></td><td><code>a |-> <1, 3, 5></code></td></tr>
                <tr><td><code>a = {x from [1..5] | x % 2 == 0};</code></td><td><code>a |-> {2, 4}</code></td></tr>
              </table>

            </section>

            <section id="map-representation">
              <h4> 2.4.3.4 Map specification based definition </h4>
              This type of representation is well suited in scenarios in which one wants to apply a certain mapping function over all elements in a source value. The mapping process has an expression whose resulting values will be contained inside the final value.<br>

              <b>Examples:</b>
              <table border="1">
                <tr><th>Representation</th><th>Final configuration</th></tr>
                <tr><td><code>a = [2 * x | x from [1..5]];</code></td><td><code>a |-> [2, 4, 6, 8, 10]</code></td></tr>
                <tr><td><code>a = <2 * x | x from [1..5]>;</code></td><td><code>a |-> <2, 4, 6, 8, 10></code></td></tr>
                <tr><td><code>a = {2 * x | x from [1..5]};</code></td><td><code>a |-> {2, 4, 6, 8, 10}</code></td></tr>
              </table>

            </section>

            <section id="empty-representation">
              <h4> 2.4.3.5 Empty definition </h4>
              There are several ways to instantiate an empty iterable data type value. Note that for some of those there are special keywords which automatically evaluated to an empty specified compound value.<br>

              <b>Examples:</b>
              <table border="1">
                <tr><th>Representation</th><th>Final configuration</th></tr>
                <tr><td><code>a = [];</code></td><td><code>a |-> []</code></td></tr>
                <tr><td><code>a = <  >;</code></td><td><code>a |-> <  ></code></td></tr>
                <tr><td><code>a = {};</code></td><td><code>a |-> {}</code></td></tr>
                <tr><td><code>a = emptyList;</code></td><td><code>a |-> <  ></code></td></tr>
                <tr><td><code>a = emptySet;</code></td><td><code>a |-> {}</code></td></tr>
              </table>

            </section>

        </section>

        <section id="functions">
          <h2> 2.5 Functions </h2>
          
          <section id="function-declaration">
            <h3> 2.5.1 Function declaration </h3>
            Functions can be declared anywhere inside the algorithm and their score is global. This is due to the fact that function declarations are statements, so they can be used inside any sequence of statements. Note that it is recommended to declare the functions to the global scope anyway.
            <table border = 1>
              <tr><th>Syntax</th></tr>
              <tr><td><code>function-name(param-list) modifies global-list</code></td></tr>
              <tr><td><code>function-name(param-list)</code></td></tr>
              <tr><td><code>function-name()</code></td></tr>
              <tr><td><code>function-name() modifies global-list</code></td></tr>
            </table> 

            <b>Function-name:</b><br>
            The function name should be an id after which the function will be identified and eventually be called.<br>
            <b>Param-list:</b><br>
            The parameters list is a component which should be replaced with a list of comma separated parameters. These can belong to a set of two types: input and output parameters. The input parameters can be changed, but the modifications won't be reflected in the calling state (so this parameters are in fact copies of the arguments used). The output parameters reference however the values provided at the function call, so any modification over these values will be made on the argument values as well. In order to mark which are the output parameters and which are not, the following syntax is used:
            <table border = 1>
              <tr><th>Syntax</th><th>Meaning</th></tr>
              <tr><td><code>param-name</code></td><td>input parameter</td></tr>
              <tr><td><code>out param-name</code></td><td>Output parameter</td></tr>
            </table> 
            The param-name component should be an id with which the value given will be referenced. Note that functions open separate environments, so any variable used here should not affect the ones in the outer scope - so the same id can be used for different values. <br>

            <b>Global-list:</b><br>
            The list which is after the modifies keyword is a list of variables from the global scope which can be changed by this function. This syntax is used in order to allow the reuse of some ids which were initially used in the global scope. Note that all the parameters which come after the modifies keyword are output parameters, so any change on those will reflect in the global scope.<br>
            <b>Examples:</b><br>
            <table border="1">
              <tr><th>Algorithm</th><th>Output</th></tr>
              <tr><td><code>func(a, b, c)<br>{<br>&nbsp;&nbsp; c = a + b;<br>&nbsp;&nbsp; print(c);<br>}<br>a = 2;<br>b = 3;<br>c = 4;<br>func(a, b, c);<br>print(c);</code></td><td><code>5<br>4</code></td></tr>
              <tr><td><code>func(a, b, out c)<br>{<br>&nbsp;&nbsp; c = a + b;<br>&nbsp;&nbsp; print(c);<br>}<br>a = 2;<br>b = 3;<br>c = 4;<br>func(a, b, c);<br>print(c);</code></td><td><code>5<br>5</code></td></tr>
              <tr><td><code>func(a, b) modifies c<br>{<br>&nbsp;&nbsp; c = a + b;<br>&nbsp;&nbsp; print(c);<br>}<br>a = 2;<br>b = 3;<br>c = 4;<br>func(a, b);<br>print(c);</code></td><td><code>5<br>5</code></td></tr>
              <tr><td><code>func(a, b)<br>{<br>&nbsp;&nbsp; c = a + b;<br>&nbsp;&nbsp; print(c);<br>}<br>a = 2;<br>b = 3;<br>c = 4;<br>func(a, b);<br>print(c);</code></td><td><code>5<br>4</code></td></tr>
            </table>
          </section>
          
          <section id="function-call-stmt">
            <h3> 2.5.2 Function call </h3>
            The function call is the main way to trigger the code inside a declared function. Note that a function can be called only after it was defined. The number of parameters should match, and the modifies list should have only ids of variables which are already in the global environment. Also, an important fact is that the output parameters can't take expressions or static values as argument. Therefore, the argument for an output parameter can be only an id (a reference). <br>
            A function call can be used inside a single function call statement. This kind of function should not necessarily return, as the returning value will be lost. The other use case is function calls inside expressions. For this scenario, the functions should return, otherwise an error will be shown.<br>
            There are already examples of function calls inside single statements in the previous section. Function calls inside expressions are shown in the next section.
          </section>

          <section id="return-call">
            <h3> 2.5.3 Return call </h3>
            In order to make a function return a value, the return statement should be used. This will take a computed value and return it to the calling context. Note that the execution of the function is halted at this point, so no other statement after the return will execute.
            <table border = 1>
              <tr><th>Syntax</th></tr>
              <tr><td><code>return;</code></td></tr>
              <tr><td><code>return expression;</code></td></tr>
            </table> 

            Note that there can be no return value. In this case, the return call is used only to trigger the stopping of the function. If a value is used however, the value will be propagated to the calling context.<br>
            <b>Expression:</b><br>
            The expression component should evaluate to a valid value which is meant to be sent to the calling context.<br>
            <b>Examples:</b><br>
            <table border="1">
              <tr><th>Algorithm</th><th>Output</th></tr>
              <tr><td><code>func(a, b)<br>{<br>&nbsp;&nbsp; return a + b;<br>}<br>a = 2;<br>b = 3;<br>print(func(a, b));</code></td><td><code>5</code></td></tr>
              <tr><td><code>func() modifies a<br>{<br>&nbsp;&nbsp; return 2 * a;<br>}<br>a = 2;<br>a += func() * 2;<br>print(a);</code></td><td><code>10</code></td></tr>
              <tr><td><code>func(out a, out b)<br>{<br>&nbsp;&nbsp; a = 2<br>&nbsp;&nbsp; return ;<br>&nbsp;&nbsp; b = 2;<br>}<br>a = 5;<br>b = 5;<br>func(a, b);<br>print(a);<br>print(b);</code></td><td><code>2<br>5</code></td></tr>
            </table>
          </section>

        </section>

        <section id="instructions">
          <h2> 2.6 Instructions </h2>
          
          <section id="simple-instructions">
            <h3> 2.6.1 Simple instructions</h3>

            <section id="assignment">
              <h4> 2.6.1.1 Assignment</h4>
              The assignment statement is a way to directly assign a specific value to a reference. The value can be of any kind as the variable can change types at the runtime according to <a href="#dynamic-allocation">dynamic typing</a>. The reference can be a simple identifier or a more complex reference which will be eventually subject to <a href="#dynamic-allocation">dynamic allocation</a>.
              <table border = 1>
                <tr><th>Syntax</th></tr>
                <tr><td><code>reference assignment-operator expression;</code></td></tr>
              </table> 

              <b>Reference:</b> <br>
              The reference usually has to point to a specific location in the store which eventually can be created by the <a href="#dynamic-allocation">dynamic allocation</a> procedure for arrays and structures. The most basic type of reference is an identifier which already exists or will be automatically created in the environment. A more complex reference is composed out of an identifier and a sequence of brackets and dot operators to indicate a specific location inside a compound data type value. <br>

              <b>Assignment-operator:</b> <br>
              There are several assignment operators which behave suggestively to their representation. The most basic assignment operator is represented through an equal sign <code>=</code>, denoting that the value in the right side will be simply copied to the location suggested by the reference in the left side. The table below shows all the assignment operators and their behaviors:
              <table border = 1>
                <tr><th>Assignment operator</th><th>Representation</th><th>Description</th></tr>
                <tr><td>Simple assign</td><td><code>=</code></td><td>Assigns the value without modifing it</td></tr>
                <tr><td>Addition assign</td><td><code>+=</code></td><td>Assigns the executionResult from the addition operation between the left-value and the specified right-value</td></tr>
                <tr><td>Subtraction assign</td><td><code>-=</code></td><td>Assigns the executionResult from the subtraction operation between the left-value and the specified right-value</td></tr>
                <tr><td>Multiplication assign</td><td><code>*=</code></td><td>Assigns the executionResult from the multiplication operation between the left-value and the specified right-value</td></tr>
                <tr><td>Division assign</td><td><code>/=</code></td><td>Assigns the executionResult from the division operation between the left-value and the specified right-value</td></tr>
                <tr><td>Mod assign</td><td><code>%=</code></td><td>Assigns the executionResult from the mod operation between the left-value and right-value</td></tr>
                <tr><td>Left shift assign</td><td><code><<=</code></td><td>Assigns the executionResult from the left shift operation between the left-value and right-value</td></tr>
                <tr><td>Right shift assign</td><td><code>>>=</code></td><td>Assigns the executionResult from the right shift operation between the left-value and right-value</td></tr>
                <tr><td>Bitwise and assign</td><td><code>&=</code></td><td>Assigns the executionResult from the bitwise and operation between the left-value and right-value</td></tr>
                <tr><td>Bitwise or assign</td><td><code>|=</code></td><td>Assigns the executionResult from the bitwise or operation between the left-value and right-value</td></tr>
              </table> 

              <b>Expression:</b> <br>
              The expression should evaluate to the value which is desired to be assigned to the specified reference. As previously stated, the data type of the executionResult shouldn't respect any limitations due to the <a href="#dynamic-allocation">dynamic allocation</a> feature. <br>

              <b>Examples:</b> <br>
              <table border = 1>
                <tr><th>Initial configuration</th><th>Assignment</th><th>Final configuration</th></tr>
                <tr><td><code>a |-> [1, 2, 3]</code></td><td><code>a = true;</code></td><td><code>a |-> true</code></td></tr>
                <tr><td><code>a |-> "abc"</code></td><td><code>a += "def";</code></td><td><code>a |-> "abcdef"</code></td></tr>
                <tr><td><code>a |-> 10.4</code></td><td><code>a -= 2.7 * 2;</code></td><td><code>a |-> 5.0</code></td></tr>
                <tr><td><code>a |-> 2</code></td><td><code>a *= (1 << 1) + 1;</code></td><td><code>a |-> 6</code></td></tr>
                <tr><td><code>a |-> 13</code></td><td><code>a /= (6 >> 1);</code></td><td><code>a |-> 4</code></td></tr>
                <tr><td><code>a |-> 13</code></td><td><code>a %= 1 + 1 + 1;</code></td><td><code>a |-> 1</code></td></tr>
                <tr><td><code>a |-> 5</code></td><td><code>a <<= 6 * 2 / 4;</code></td><td><code>a |-> 40</code></td></tr>
                <tr><td><code>a |-> 47</code></td><td><code>a >>= 8 % 5;</code></td><td><code>a |-> 5</code></td></tr>
                <tr><td><code>a |-> 5</code></td><td><code>a &= a + 1;</code></td><td><code>a |-> 4</code></td></tr>
                <tr><td><code>a |-> 6</code></td><td><code>a |= a - 1;</code></td><td><code>a |-> 7</code></td></tr>
                <tr><td><code>a |-> [1, 2, 3, 4]</code></td><td><code>a[2] = 5;</code></td><td><code>a |-> [1, 2, 5, 4]</code></td></tr>
                <tr><td><code>a |-> {x -> 3 y -> 2}</code></td><td><code>a.x = 7;</code></td><td><code>a |-> {x -> 7 y -> 2}</code></td></tr>
                <tr><td><code>a |-> [1, {x -> 3 y -> 2}, 2, 3]</code></td><td><code>a[1].y = 7;</code></td><td><code>a |-> [1, {x -> 3 y -> 7}, 2, 3]</code></td></tr>
                <tr><td><code>a |-> {x -> [1, 2, 3] y -> 2}</code></td><td><code>a.x[1] = 7;</code></td><td><code>a |-> {x -> [1, 7, 3] y -> 2}</code></td></tr>
                <tr><td><code></code></td><td><code>a[0][2].x[2].y = 7;</code></td><td><code>a |-> [[?, ?, {x -> [?, ?, {y -> 7}]}]]</code></td></tr>
              </table> 

            </section>

            <section id="function-call">
              <h4> 2.6.1.2 Function Call</h4>
              The function call statement is used in order to execute a specific function whose return value is not intended to be used in any expression. It is recommended to run in this way only the functions which do not return values. As any function call, this should respect the norms described in the <a href="#function-call-stmt"> function-call </a> section: match the name of the function, the number of parameters and pass only references to output parameters. Note that this statement can be used in order to also call <a href="#builtin-functions">builtin functions</a> like <code>print</code>.
              <table border = 1>
                <tr><th>Syntax</th></tr>
                <tr><td><code>function-call;</code></td></tr>
              </table> 
              <b>Function-call:</b> <br>
              This is the only part of the statement which should be defined. The definition is already described in the <a href="#function-declaration">function declaration</a> section. <br>
              <b>Examples:</b> <br>
              <table border = 1>
                <tr><th>Initial configuration</th><th>Function Call</th><th>Description</th><th>Final configuration</th></tr>
                <tr><td><code></code></td><td><code>print([1, 2, 3]);</code></td><td>Use the print builtin function in order to print <code>[1, 2, 3]</code></td></td><td></td></tr>
                <tr><td><code>a |-> 15 b |-> 12 c |-> 0</code></td><td><code>gcd(a, b);</code></td><td>Presume that the custom gcd function computes the greatest common division of <i>a</i> and <i>b</i> and assigns it to <i>c</i></td></td><td><code>a |-> 15 b |-> 12 c |-> 3</code></td></tr>
                <tr><td><code>a |-> 2 b |-> 3</code></td><td><code>swap(a, b);</code></td><td>Presume that the custom swap function interchanges the values of <i>a</i> and <i>b</i></td></td><td><code>a |-> 3 b |-> 2</code></td></tr>
                <tr><td><code>a |-> [5, 2, 4, 1, 3]</code></td><td><code>sort(a);</code></td><td>Presume that the custom sort function sorts the elements of <i>a</i> in-place</td></td><td><code>a |-> [1, 2, 3, 4, 5]</code></td></tr>
              </table> 
            </section>

            <section id="method-call">
              <h4> 2.6.1.3 Method Call</h4>
              The method call statement is used in order to execute a specific <a href="#builtin-methods"> builtin method</a> over a given target value. Is is not recommended to use <a href="#query-builtin-methods">query builtin methods</a> in this fashion as they will have no effect after all. This is mainly meant to be used together with <a href="#update-builtin-methods">update builtin methods</a>. 
              <table border = 1>
                <tr><th>Syntax</th></tr>
                <tr><td><code>method-call;</code></td></tr>
              </table>
              <b>Method-call:</b> <br>
              This is the only part of the statement which should be defined. The definition is already described in the <a href="#builtin-methods">methods</a> section. <br>

              <b>Examples:</b> <br>
              <table border = 1>
                <tr><th>Initial configuration</th><th>Method Call</th><th>Final configuration</th></tr>
                <tr><td><code>a |-> [1, 2, 3]</code></td><td><code>a.pushBack(4);</code></td><td><code>a |-> [1, 2, 3, 4]</code></td></tr>
                <tr><td><code>a |-> [1, <1, 2, 3>, 3]</code></td><td><code>a[1].popBack();</code></td><td><code>a |-> [1, <1, 2>, 3]</code></td></tr>
                <tr><td><code>a |-> {x -> [1, 2, 3] y -> [1]}</code></td><td><code>a.x.popFront();</code></td><td><code>a |-> {x -> [2, 3] y -> [1]}</code></td></tr>
              </table> 
            </section>

            <section id="id-instruction">
              <h4> 2.6.1.4 Increment/Decrement</h4>
              The increment/decrement statement is a sugar syntax for a simple assignment. This makes use of the <a href="#id-operator">increment/decrement</a> operator described in the expressions section. The meaning of each syntax is related to the meaning of the operator used: increment or decrement, prefix or postfix.
              <table border = 1>
                <tr><th>Syntax</th></tr>
                <tr><td><code>reference++;</code></td></tr>
                <tr><td><code>reference--;</code></td></tr>
                <tr><td><code>++reference;</code></td></tr>
                <tr><td><code>--reference;</code></td></tr>
              </table>
            </section>

            <b>Reference:</b> <br>
            The reference usually has to point to a specific location in the store which eventually can be created by the <a href="#dynamic-allocation">dynamic allocation</a> procedure for arrays and structures. The most basic type of reference is an identifier which already exists or will be automatically created in the environemnt. A more complex reference is composed out of an identifier and a sequence of brackets and dot operators to indicate a specific location inside a compound data type value. <br>

            <b>Examples:</b> <br>
            <table border = 1>
              <tr><th>Initial configuration</th><th>Increment/Decrement</th><th>Final configuration</th></tr>
              <tr><td><code>a |-> 5</code></td><td><code>a++;</code></td><td><code>a |-> 6</code></td></tr>
              <tr><td><code>a |-> 5.5</code></td><td><code>++a;</code></td><td><code>a |-> 6.5</code></td></tr>
              <tr><td><code>a |-> 5.5</code></td><td><code>a--;</code></td><td><code>a |-> 4.5</code></td></tr>
              <tr><td><code>a |-> 5</code></td><td><code>--a;</code></td><td><code>a |-> 4</code></td></tr>
            </table> 

          </section>
          
          <section id="compound-intructions">
            <h3> 2.6.2 Compound instructions </h3>
            Compound instructions are used in order to group several statement into a single one. The execution is still sequential; basically there is no impact on efficiency when using compound instructions. The main reason to use those is to allow the developer to put multiple statements inside a complex statement like a conditional or repetitive instruction. The syntax is intuitive: one should enclose the sequence of statement inside curly braces.
            <table border = 1>
              <tr><th>Syntax</th></tr>
              <tr><td><code>{ statements }</code></td></tr>
            </table>
            <b>Statements:</b><br>
            The statement component is a list of statements which are meant to be grouped inside the compound instruction. There is no restriction whatsoever on the type of statements.

            <b>Examples:</b> <br>
            <table border = 1>
              <tr><th>Initial configuration</th><th>Assignment</th><th>Final configuration</th></tr>
              <tr><td><code>a |-> 5</code></td><td><code>{<br>&nbsp&nbsp a = 5;<br>&nbsp&nbsp a = 8;<br> }</code></td><td><code>a |-> 8</code></td></tr>
              <tr><td><code>a |-> 5.5</code></td><td><code>{<br>&nbsp&nbsp a += 1;<br>&nbsp&nbsp print(a);<br>&nbsp&nbsp a -= 2;<br>}</code></td><td><code>a |-> 4.5</code></td></tr>
            </table> 
            
          </section>
          
          <section id="conditional-instruction">
            <h3> 2.6.3 Conditional instruction - if/else </h3>
            The conditional instruction is used in order to put a condition over the execution of a statement (or implicitly a sequence of statements if the compound instruction is used). The conditioning is based on an expression which should evaluate to a bool value (the use of any other kind of data type value will executionResult into an error). In case the execution should choose between two statements based on a condition, the <code>if</code> and <code>else</code> keywords should be used. Otherwise, meaning that only one statement should be be executed or not, it is enough to use only the <code>if</code> keyword.
            <table border = 1>
              <tr><th>Syntax</th></tr>
              <tr><td><code>if (bool-expression) statement1</code></td></tr>
              <tr><td><code>if (bool-expression) statement1 else statement2</code></td></tr>
            </table>
            <b>Bool-expression:</b><br>
            The bool-expression component refers to the condition used for the conditional instruction. It is clear the fact that this expression should evaluate to a bool value. In case the expression evaluates to <code>true</code>, then <code>statement1</code> will be executed. Otherwise, it depends upon the syntax used. If no <code>else</code> keyword is used, then nothing happens (the expression evaluates to <code>false</code>). In case the <code>else</code> keyword is used and the expression evaluates to <code>false</code>, then <code>statement2</code> will be executed.<br>

            <b>Statement1 and statement2:</b><br>
            Statement1 refers to the statement which will be executed in case the expression evaluates to <code>true</code>. This can be any kind of statement (compound instruction included and even recommended). Statement2 refers to the statement which will be executed in case the <code>else</code> keyword is used and the expression evaluates to <code>false</code>. This also can represent any kind of statement (compound instruction included and even recommended). <br>
            <b>Examples:</b>
            <table border = 1>
              <tr><th>Initial configuration</th><th>Conditional instruction</th><th>Final configuration</th></tr>
              <tr><td><code>a |-> 5</code></td><td><code>if (a % 2 == 0) <br>&nbsp&nbsp b = "a is even";<br> else<br>&nbsp&nbsp b = "a is odd";</code></td><td><code>a |-> 5<br>b |-> "a is odd"</code></td></tr>
              <tr><td><code>a |-> 10</code></td><td><code>if (a % 2 == 0) <br>&nbsp&nbsp b = "a is even";<br> else<br>&nbsp&nbsp b = "a is odd";</code></td><td><code>a |-> 5<br>b |-> "a is even"</code></td></tr>
              <tr><td><code>a |-> 12345</code></td><td><code>if (a > 100)<br>&nbsp&nbsp a = 100;</code></td><td><code>a |-> 100</code></td></tr>
              <tr><td><code>a |-> 24</code></td><td><code>if (a > 100)<br>&nbsp&nbsp a = 100;</code></td><td><code>a |-> 24</code></td></tr>
              <tr><td><code>a |-> 2<br>b |-> 5</code></td><td><code>if (a > 0 && b > 0)<br>{<br>&nbsp&nbsp a = -a;<br>&nbsp&nbsp b = -b;<br>}</code></td><td><code>a |-> -2<br>b |-> -5</code></td></tr>
              <tr><td><code>a |-> -2<br>b |-> -100</code></td><td><code>if (a > 0 && b > 0)<br>{<br>&nbsp&nbsp a = -a;<br>&nbsp&nbsp b = -b;<br>}<br>else<br>{<br>&nbsp&nbsp a = 0;<br>&nbsp&nbsp b = 1;<br>}</code></td><td><code>a |-> 0<br>b |-> 1</code></td></tr>
            </table> 
          </section>
          
          <section id="repetitive-instrictions">
            <h3> 2.6.4 Repetitve instructions</h3>

            <section id="while-instruction">
              <h4> 2.6.4.1 While instruction</h4>
              The while instruction is a repetitive statement with initial check which will execute a specific statement multiple times until a given condition evaluates to <code>false</code>. Note that the condition provided should always evaluate to a bool value, otherwise an error will be displayed. The statement can be of any type as there is no restriction over it (the statement can be even a compound instruction which is in fact recommended).
              <table border = 1>
                <tr><th>Syntax</th></tr>
                <tr><td><code>while (bool-expression) statement</code></td></tr>
              </table>
              <b>Bool-expression:</b><br>
              The bool-expression component refers to the condition used for the while instruction. It is clear that this expression should evaluate to a bool value. Before the first iteration, the expression is evaluated. In case it evaluates to <code>true</code> then the statement is executed. Otherwise the process is halted and the while instruction is skipped. After each iteration, the condition is re-evaluated following the same behavior: if the condition evaluates to <code>true</code> the next iteration is triggered. Otherwise, the looping process ends and the while instruction is skipped. <br>
              <b>Statement:</b><br>
              Statement refers to the component which should be executed every time the expression evaluates to <code>true</code>. Note that the statement can be of any kind. Due to instruction's definition, there are cases in which this statement will never be executed.<br>

              <b>Examples:</b>
              <table border = 1>
                <tr><th>Initial configuration</th><th>While instruction</th><th>Final configuration</th></tr>
                <tr><td><code>a |-> 156</code></td><td><code>while (a > 100) <br>&nbsp&nbsp a--;</code></td><td><code>a |-> 100</code></td></tr>
                <tr><td><code>a |-> 28</code></td><td><code>while (a > 100) <br>&nbsp&nbsp a--;</code></td><td><code>a |-> 28</code></td></tr>
                <tr><td><code>a |-> 1 <br> b |-> 10</code></td><td><code>while (abs(a - b) > 5 && a < b) <br>{<br>&nbsp&nbsp a++;<br>&nbsp&nbsp b--;<br>}</code></td><td><code>a |-> 3<br>b |-> 8</code></td></tr>
                <tr><td><code>a |-> 15 <br> b |-> 12</code></td><td><code>while (b > 0) <br>{<br>&nbsp&nbsp r = a % b;<br>&nbsp&nbsp a = b;<br>&nbsp&nbsp b = r;<br>}</code></td><td><code>a |-> 3<br>b |-> 0<br>r |-> 0</code></td></tr>
              </table> 

            </section>

            <section id="do-while-intruction">
              <h4> 2.6.4.2 Do-while instruction</h4>
              The do-while instrucion is a repetitive statement with final check which will execute a specific statement multiple times until a given condition evaluates to <code>false</code>. Note that the condition provided should always evaluate to a bool value, otherwise an error will be displayed. The statement can be of any type as there is no restriction over it (the statement can be even a compound instruction which is in fact recommended). Comparing to a simple while instruction, the do-while instruction evaluates the condition only at the end. This means that the statement will be executed at least once.
              <table border = 1>
                <tr><th>Syntax</th></tr>
                <tr><td><code>do statement while (bool-expression);</code></td></tr>
              </table>
              <b>Bool-expression:</b><br>
              The bool-expression component refers to the condition used for the do-while instruction. It is clear the fact that this expression should evaluate to a bool value. The first iteration will be done without checking the condition. After each iteration, the condition is evaluated: if the condition evaluates to <code>true</code> the next iteration is triggered. Otherwise, the looping process ends and the while instruction is skipped. <br>
              <b>Statement:</b><br>
              Statement refers to the component which should be executed every time the expression evaluates to <code>true</code>. Note that the statement can be of any kind. Due to instruction's definition, the statement will execute at least once no matter the condition.<br>

              <b>Examples:</b>
              <table border = 1>
                <tr><th>Initial configuration</th><th>Do-while instruction</th><th>Final configuration</th></tr>
                <tr><td><code>a |-> 156</code></td><td><code>do <br>&nbsp&nbsp a--;<br>while (a > 100);</code></td><td><code>a |-> 100</code></td></tr>
                <tr><td><code>a |-> 28</code></td><td><code>do <br>&nbsp&nbsp a--;<br>while (a > 100);</code></td><td><code>a |-> 27</code></td></tr>
                <tr><td><code>a |-> 5 <br> b |-> 5</code></td><td><code>do<br>{<br>&nbsp&nbsp a++;<br>&nbsp&nbsp b--;<br>}<br>while (abs(a - b) > 5 && a < b);</code></td><td><code>a |-> 6<br>b |-> 4</code></td></tr>
                <tr><td><code>a |-> 15 <br> b |-> 12</code></td><td><code>do<br>{<br>&nbsp&nbsp r = a % b;<br>&nbsp&nbsp a = b;<br>&nbsp&nbsp b = r;<br>}<br>while (b > 0);</code></td><td><code>a |-> 3<br>b |-> 0<br>r |-> 0</code></td></tr>
              </table> 
            </section>

            <section id="repeat-until">
              <h4> 2.6.4.3 Repeat-until intruction</h4>
              The repeat-until instruction is a repetitive statement with final check which will execute a specific statement multiple times until a given condition evaluates to <code>true</code>. Note that the condition provided should always evaluate to a bool value, otherwise an error will be displayed. The statement can be of any type as there is no restriction over it (the statement can be even a compound instruction which is in fact recommended). Comparing to a do-while instruction, the do-while is halted when the condition evaluates to <code>false</code>. The repeat-until statement is halted when the condition is evaluated to <code>true</code>
              <table border = 1>
                <tr><th>Syntax</th></tr>
                <tr><td><code>repeat statement until (bool-expression);</code></td></tr>
              </table>
              <b>Bool-expression:</b><br>
              The bool-expression component refers to the condition used for the repeat-until instruction. It is clear the fact that this expression should evaluate to a bool value. The first iteration will be done without checking the condition. After each iteration, the condition is evaluated: if the condition evaluates to <code>false</code> the next iteration is triggered. Otherwise, the looping process ends and the while instruction is skipped. <br>
              <b>Statement:</b><br>
              Statement refers to the component which should be executed every time the expression evaluates to <code>false</code>. Note that the statement can be of any kind. Due to instruction's definition, the statement will execute at least once no matter the condition.<br>

              <b>Examples:</b>
              <table border = 1>
                <tr><th>Initial configuration</th><th>Repeat-until instruction</th><th>Final configuration</th></tr>
                <tr><td><code>a |-> 156</code></td><td><code>repeat <br>&nbsp&nbsp a--;<br>until (a > 100);</code></td><td><code>a |-> 155</code></td></tr>
                <tr><td><code>a |-> 234</code></td><td><code>repeat <br>&nbsp&nbsp a--;<br>until (a == 100);</code></td><td><code>a |-> 100</code></td></tr>
                <tr><td><code>a |-> -10 <br> b |-> 10</code></td><td><code>repeat<br>{<br>&nbsp&nbsp a++;<br>&nbsp&nbsp b--;<br>}<br>until (abs(a - b) < 5);</code></td><td><code>a |-> -2<br>b |-> 2</code></td></tr>
                <tr><td><code>a |-> 15 <br> b |-> 12</code></td><td><code>repeat<br>{<br>&nbsp&nbsp r = a % b;<br>&nbsp&nbsp a = b;<br>&nbsp&nbsp b = r;<br>}<br>until (b == 0);</code></td><td><code>a |-> 3<br>b |-> 0<br>r |-> 0</code></td></tr>
              </table> 
            </section>

            <section id="for-instruction">
              <h4> 2.6.4.4 For instruction</h4>
              The for instruction is a repetitive statement with initial check which will execute a specific statement multiple times until a given condition evaluates to <code>true</code>. Note that the condition provided should always evaluate to a bool value, otherwise an error will be displayed. The statement can be of any type as there is no restriction over it (the statement can be even a compound instruction which is in fact recommended). Comparing to a while instruction, the for instruction also provides support for initial assignment (oftenly used for initializing an iterator) and support for intermediary assignment or increase/decrease (oftenly used to change the iterator).
              <table border = 1>
                <tr><th>Syntax</th></tr>
                <tr><td><code>for (initial-assign; bool-expression; intermediary-assign) statement</code></td></tr>
                <tr><td><code>for (initial-assign; bool-expression; increase/decrease) statement</code></td></tr>
              </table>
              <b>Bool-expression:</b><br>
              The bool-expression component refers to the condition used for the for instruction. It is clear the fact that this expression should evaluate to a bool value. At first, the <code>initial-assign</code> is executed. Before the first iteration, the expression is evaluated. In case it evaluates to <code>true</code> then the statement is executed. Otherwise the process is halted and the for instruction is skipped. After each iteration, the condition is re-evaluated following the same behavior: if the condition evaluates to <code>true</code> the next iteration is triggered. Otherwise, the looping process ends and the while instruction is skipped. Note that before the expression is re-evaluated, the <code>intermediary-assign</code> is executed.<br>
              <b>Initial-assign:</b><br>
              The initial assign is used in order to assign to an eventual iterator a value. This will be executed before anything else. Note that the initial assign can be omitted.<br>

              <b>Intermediary-assign:</b><br>
              The intermediary assign is executed after each loop before the expression is re-evaluated. This should be used in order to change the iterator in a more complex way than an increase/decrease (which can be done with the other syntax version).<br>

              <b>Increase/Decrease:</b><br>
              The increase/decrease is semantically the same thing as a intermediary-assign. Instead of using the assignment specific syntax, this component implies that one can change the iterator with a simple increase/decrease operator.<br>

              <b>Statement:</b><br>
              Statement refers to the component which should be executed every time the expression evaluates to <code>true</code>. Note that the statement can be of any kind. Due to instruction's definition, there are cases in which this <code>statement</code> will never be executed.<br>

              <b>Examples:</b>
              <table border = 1>
                <tr><th>Initial configuration</th><th>For instruction</th><th>Final configuration</th></tr>
                <tr><td><code>s |-> 0</code></td><td><code>for(i = 1; i <= 10; i++) <br>&nbsp&nbsp s += i;</code></td><td><code>s |-> 55<br>i |-> 11</code></td></tr>
                <tr><td><code>s |-> 0</code></td><td><code>for(; s < 10; s++) <br>&nbsp&nbsp s *= 2;</code></td><td><code>s |-> 15</code></td></tr>
                <tr><td><code>s |-> 0</code></td><td><code>for(i = 1; i <= 10; i += 2) <br>&nbsp&nbsp s += i;</code></td><td><code>s |-> 25<br>i |-> 11</code></td></tr>
                <tr><td><code>s |-> 0</code></td><td><code>for(i = 1; i != 5 && i < 100; i++) <br>&nbsp&nbsp s += i;</code></td><td><code>s |-> 10<br>i |-> 5</code></td></tr>
                <tr><td><code></code></td><td><code>for(s = 0; false; s = 10) <br>&nbsp&nbsp s += 2;</code></td><td><code>s |-> 0</code></td></tr>
                <tr><td><code>s |-> 0</code></td><td><code>for(i = 10; i >= 1; i--) <br>{<br>&nbsp&nbsp s += i;<br>&nbsp&nbsp s *= 2;<br>}<br></code></td><td><code>s |-> 18434<br>i |-> 0</code></td></tr>
              </table> 
            </section>

            <section id="foreach-instruction">
              <h4> 2.6.4.5 Foreach instruction</h4>
              The foreach instruction is a repetitive statement which does not depend upon a given conditional expression. The foreach instruction is meant to be used when one wants to sequentially access the elements of an iterable compound data type value. The statement will assign a given variable to each element from the collection given and afterwards will execute the underlying statement. Note that the values do not reference the original ones inside the data type value (this means that any modification on the foreach variable won't take effect in the original structure).

              <table border = 1>
                <tr><th>Syntax</th></tr>
                <tr><td><code>foreach id in iterable statement</code></td></tr>
              </table>

              <b>Id:</b><br>
              The id represent the variable which is meant to be used in order to access the given iterable. This variable can be used afterwards in the underlying statement. The denoted variable shouldn't be necessarily initialized in any way - it will be dynamically assigned if not already in the environment.<br>
              <b>Iterable:</b><br>
              The iterable component represent the value which is meant to be iterated. There are only three data type values which are eligible for this operation: array, list and set. The order in which the elements will be iterated depends upon the way in which they are stored. For the array and list data types, the elements will be iterated normally from the lower index to the higher index. The sets however are iterated randomly (however, multiple iterations can iterate the set in the same order).<br>
              <b>Statement:</b><br>
              Statement refers to the component which will be executed multiple types. Note that there is no limitation on the type of the statement (it can be a compound instruction). The number of executions is equal to the size of the iterated value. Each iteration will change the environment (as the iterator itself will be changed) so the statement will work on different values of <code>id</code> each time. <br>

              <b>Examples:</b>
              <table border = 1>
                <tr><th>Initial configuration</th><th>Foreach instruction</th><th>Final configuration</th></tr>
                <tr><td><code>A |-> [1, 2, 3]<br>s |-> 0</code></td><td><code>foreach x in A <br>&nbsp&nbsp s += x;</code></td><td><code>A |-> [1, 2, 3]<br>s |-> 6<br>x |-> 3</code></td></tr>
                <tr><td><code>s |-> 0</code></td><td><code>foreach x in {5, 2, 3, 4} <br>&nbsp&nbsp s = s * 10 + x;</code></td><td><code>s |-> 2354<br>x |-> 4</code></td></tr>
                <tr><td><code>s |-> 0</code></td><td><code>foreach x in <5, 2, 3, 4><br>{<br>&nbsp&nbsp s = s * 10 + x;<br>&nbsp&nbsp A[x] = 1;<br>}</code></td><td><code>A |-> [?, ?, 1, 1, 1, 1]<br>s |-> 5234<br>x |-> 4</code></td></tr>
                <tr><td><code>s |-> 0<br>A |-> [0, 0, 0, 0, 0]</code></td><td><code>foreach x in {1, 2, 3} U {2, 3, 4}<br>{<br>&nbsp&nbsp s += x;<br>&nbsp&nbsp A[x]++;<br>}</code></td><td><code>A |-> [0, 1, 1, 1, 1]<br>s |-> 10<br>x |-> 1</code></td></tr>
              </table> 

            </section>

            <section id="break-continue">
              <h4> 2.6.4.6 Break and continue instruction</h4>
              The break and continue instructions are not repetitive statements themselves. They are controlling the looping in a sense in which a continue statement can halt the execution of a loop while the break statement halts the execution of the entire lopping structure itself. They should be used when only inside of a looping statement (but not necessarily directly inside - it can be enclosed in a conditional statement for example). These only take effect on the closest looping statement, while the outer ones are not effected.
              <table border = 1>
                <tr><th>Syntax</th></tr>
                <tr><td><code>continue;</code></td></tr>
                <tr><td><code>break;</code></td></tr>
              </table>

              <b>Examples:</b>
              <table border = 1>
                <tr><th>Initial configuration</th><th>Foreach instruction</th><th>Final configuration</th></tr>
                <tr><td><code>s |-> 0</code></td><td><code>while (s < 10)<br>{<br>&nbsp&nbsp s++;<br>&nbsp&nbsp if (s == 5)<br>&nbsp&nbsp {<br>&nbsp&nbsp&nbsp&nbsp&nbsp break;<br>&nbsp&nbsp }<br>}</code></td><td><code>s |-> 5</code></td></tr>
                <tr><td><code>s |-> 0</code></td><td><code>for (i = 1; i < 5; i++)<br>{<br>&nbsp&nbsp if (i == 3)<br>&nbsp&nbsp {<br>&nbsp&nbsp&nbsp&nbsp&nbsp continue;<br>&nbsp&nbsp }<br>&nbsp&nbsp s = s * 10 + i;<br>}</code></td><td><code>s |-> 124<br>i |-> 5</code></td></tr>
                <tr><td><code>s |-> 0<br>i |-> 1</code></td><td><code>do<br>{<br>&nbsp&nbsp if (i == 3)<br>&nbsp&nbsp {<br>&nbsp&nbsp&nbsp&nbsp&nbsp break;<br>&nbsp&nbsp }<br>&nbsp&nbsp s = s * 10 + i;<br>&nbsp&nbsp i++;<br>}<br>while (i < 5);</code></td><td><code>s |-> 12<br>i |-> 3</code></td></tr>
                <tr><td><code>s |-> 0<br>i |-> 1</code></td><td><code>repeat<br>{<br>&nbsp&nbsp i++;<br>&nbsp&nbsp if (i == 3)<br>&nbsp&nbsp {<br>&nbsp&nbsp&nbsp&nbsp&nbsp continue;<br>&nbsp&nbsp }<br>&nbsp&nbsp s = s * 10 + i;<br>}<br>until (i == 5);</code></td><td><code>s |-> 245<br>i |-> 5</code></td></tr>
                <tr><td><code>s |-> 0<br>A |-> [5, 7, 2, 3, 9]</code></td><td><code>foreach x in A<br>{<br>&nbsp&nbsp if (i == 3)<br>&nbsp&nbsp {<br>&nbsp&nbsp&nbsp&nbsp&nbsp break;<br>&nbsp&nbsp }<br>&nbsp&nbsp s = s * 10 + x;<br>}</code></td><td><code>A |-> [5, 7, 2, 3, 9]<br>s |-> 572<br>x |-> 3</code></td></tr>
              </table> 

            </section>

          </section>
          
          <section id="nondeterministic-instruction">
            <h3> 2.6.5 Nondeterministic instructions </h3>

            <section id="choose-instruction">
              <h4> 2.6.5.1 Choose/such that instruction</h4>
              The choose statement is the main tool to trigger a nondeterministic execution. A choose statement nondeterministically chooses an element from a given iterable value and assigns it to a specified variable. One can also specify an expression which should evaluate to a bool value and can be used as a hint for the statement to choose only values validating the expression. If the choose instruction can't find a suitable value, the execution will executionResult in failure.
              <table border = 1>
                <tr><th>Syntax</th></tr>
                <tr><td><code>choose id in iterable;</code></td></tr>
                <tr><td><code>choose id in iterable s.t. expression;</code></td></tr>
              </table>

              We can consider the first syntax version as a sugar syntax for the case when one doesn't want to put constraints on the selected element: <code>choose id in iterable s.t. true;</code> is equivalent to <code>choose id in iterable;</code><br>
              <b>Id:</b><br>
              The id is the component which defines the variable which will be used to store the chosen value selected by the choose statement from the iterable value.<br>
              <b>Iterable:</b><br>
              The iterable is a compound data type value which can be normally iterated and is valid for such operation: array, list and set. The data type used for this is totally irrelevant. However, an empty iterable will always cause a failure in the execution. For the choose to succeed, one should provide a non-empty iterable which eventually has at least one element satisfying the such that clause.<br>
              <b>Expression:</b><br>
              The expression is not mandatory as it can be seen in the first syntax version. If such expression is defined, the choose statement will only assign the given variable a value which also makes the expression evaluate to <code>true</code>. If the expression invalidates all the elements from the list, the execution will fail. <br>

              <b>Examples:</b>
              <table border = 1>
                <tr><th>Initial configuration</th><th>Choose/such that instruction</th><th>Final configuration (nondeterministic)</th><th>Success/Failure</th></tr>
                <tr><td></td><td><code>choose x in {1, 2, 3} U {2, 3, 4};</code></td><td><code>x |-> 3</code></td><td><code>success</code></td></tr>
                <tr><td></td><td><code>choose x in {};</code></td><td><code></code></td><td><code>failure</code></td></tr>
                <tr><td><code>A |-> [1, 2, 3, 4, 5]</code></td><td><code>choose x in A;</code></td><td><code>A |-> [1, 2, 3, 4, 5]<br>x |-> 1</code></td><td><code>success</code></td></tr>
                <tr><td></td><td><code>choose x in <1..10> s.t. x % 2 == 0;</code></td><td><code>x |-> 6</code></td><td><code>success</code></td></tr>
                <tr><td></td><td><code>choose x in {1, 3, 5, 7} s.t. x % 2 == 0;</code></td><td></td><td><code>failure</code></td></tr>
                <tr><td></td><td><code>choose x in <1..10> s.t. x % 2 == 1;</code></td><td><code>x |-> 5</code></td><td><code>success</code></td></tr>
                <tr><td></td><td><code>choose x in [4, 3, 2, 1] s.t. x > 4;</code></td><td></td><td><code>failure</code></td></tr>
              </table> 

            </section>

            <section id="success-failure">
              <h4> 2.6.5.2 Success and failure instructions</h4>
              The success and failure statements are used to halt the entire execution of a program. These should be used only in nondeterministic executions in order to symbolize the fact that a selection branch fails or succeeds. An execution can also fail due to the "such that" clause inside the choose statement. However, if one can't decide at that point if a branch should fail or not, it should use the failure statement afterwards. Opposite to this, the success statement marks the end of a branch in a desired state.
              <table border = 1>
                <tr><th>Syntax</th></tr>
                <tr><td><code>failure;</code></td></tr>
                <tr><td><code>success;</code></td></tr>
              </table>

              <b>Examples:</b>
              <table border = 1>
                <tr><th>Initial configuration</th><th>Success/Failure Instructions</th><th>Final configuration (nondeterministic)</th><th>Success/Failure</th></tr>
                <tr><td></td><td><code>choose x in {1, 2, 3, 4};<br>if (x <= 2)<br>&nbsp&nbsp failure;<br>a = x;<br>x = -2;<br>success;</code></td><td><code>x |-> 1</code></td><td><code>failure</code></td></tr>
                <tr><td></td><td><code>choose x in {1, 2, 3, 4};<br>if (x <= 2)<br>&nbsp&nbsp failure;<br>a = x;<br>x = -2;<br>success;</code></td><td><code>a |-> 3<br>x |-> -2</code></td><td><code>success</code></td></tr>
              </table> 
            </section>

          </section>
          
          <section id="probabilistic-instruction">
            <h3> 2.6.6 Probabilistic instructions </h3>

            <section id="random-function">
              <h4> 2.6.6.1 Random builtin function</h4>
              Beside the classic <a href="#builtin-functions">builtin functions</a>, which are used in deterministic executions, the <code>random</code> builtin function is the main way to trigger a probabilistic execution. It is used to get a number in a specified range with uniform distribution. That being said, this is a returning function so it should be used inside expressions.<br>
              <table border = 1>
                <tr><th>Syntax</th></tr>
                <tr><td><code>random(right-limit)</code></td></tr>
              </table>

              <b>Right-limit</b><br>
              This limit represents the upper bound of the selection interval. Note that the lower bound is always 1.<br>

              <b>Examples:</b>
              <table border = 1>
                <tr><th>Initial configuration</th><th>Random Function</th><th>Final configuration (nondeterministic)</th></tr>
                <tr><td></td><td><code>x = random(5);</code></td><td><code>x |-> 1 with 20% probability</code></td></tr>
                <tr><td></td><td><code>x = random(5);</code></td><td><code>x |-> 4 with 20% probability</code></td></tr>
                <tr><td><code>a |-> 1</code></td><td><code>c = random(a);</code></td><td><code>a |-> 1<br>c |-> 1 with 100% probability</code></td></tr>
              </table> 

            </section>

            <section id="uniform-instruction">
              <h4> 2.6.6.2 Uniform instruction</h4>
              The uniform instruction is the probabilistic version of the nondeterministic choose statement. The uniform instruction itself has the same syntax as the choose statement, but it used the uniform keyword in the beginning. The major difference is that this uniform statement returns a number from the given source with uniform distribution.<br>
              <table border = 1>
                <tr><th>Syntax</th></tr>
                <tr><td><code>uniform id in iterable;</code></td></tr>
                <tr><td><code>uniform id in iterable s.t. expression;</code></td></tr>
              </table>

              We can consider the first syntax version as a sugar syntax for the case when one doesn't want to put constraints on the selected element: <code>uniform id in iterable s.t. true;</code> is equivalent to <code>uniform id in iterable;</code><br>
              <b>Id:</b><br>
              The id is the component which defines the variable which will be used to store the value selected by the uniform statement from the iterable value.<br>
              <b>Iterable:</b><br>
              The iterable is a compound data type value which can be normally iterated and is valid for such operation: array, list and set. The data type used for this is totally irrelevant. However, an empty iterable will always cause a failure in the execution. For the uniform to succeed, one should provide a non-empty iterable which eventually has at least one element satisfying the such that clause.<br>
              <b>Expression:</b><br>
              The expression is not mandatory as it can be seen in the first syntax version. If such expression is defined, the uniform statement will only assign the given variable a value which also makes the expression evaluate to <code>true</code>. If the expression invalidates all elements from the list, the execution will fail. <br>


              <b>Examples:</b>
              <table border = 1>
                <tr><th>Initial configuration</th><th>Uniform/such that instruction</th><th>Final configuration (probabilistic)</th></tr>
                <tr><td></td><td><code>uniform x in {1, 2, 3} U {2, 3, 4};</code></td><td><code>x |-> 3 with 25% probability</code></td></tr>
                <tr><td><code>A |-> [1, 2, 3, 4, 5]</code></td><td><code>uniform x in A;</code></td><td><code>A |-> [1, 2, 3, 4, 5]<br>x |-> 1 with 20% probability</code></td></tr>
                <tr><td></td><td><code>uniform x in <1..10> s.t. x % 2 == 0;</code></td><td><code>x |-> 6 with 20% probability</code></td></tr>
                <tr><td></td><td><code>uniform x in <1..10> s.t. x % 2 == 1;</code></td><td><code>x |-> 5 with 20% probability</code></td></tr>
              </table> 
            </section>

          </section>

        </section>

    </section>

    <!--<section id="executions">
      <h1> 3 Executions</h1>

      <section id="deterministic-executions">
        <h2> 3.1 Deterministic executions</h2>
        ...
      </section>

      <section id="nondeterministic-executions">
        <h2> 3.2 Nondeterministic executions</h2>
        
        <section id="exhaustive-execution">
          <h3> 3.2.1 Exhaustive execution principle</h3>
          ...
        </section>

        <section id="nondeterministic-algorithm">
          <h3> 3.2.2 Nondeterministic algorithm structure</h3>
          ...
        </section>

        <section id="final-configuration">
          <h3> 3.2.3 Final configuration</h3>
          ...
        </section>

      </section>

      <section id="probabilistic-execution">
        <h2> 3.3 Probabilistic executions</h2>
        ...
      </section>

    </section>

    <section id="error-undestanding">
      <h1> 4 Error understanding</h1>

      <section id="error-format">
        <h2> 4.1 Error format</h2>
        ...
      </section>

      <section id="debug-technique">
        <h2> 4.2 Debug techniques</h2>
        ...
      </section>

    </section> -->

    <section id="options">
      <h1> 3 Options</h1>

      <section id="option-a">
        <h2> 3.1 Setting the algorithm to be run</h2>
        This option is the most important as it defines the file which should be parsed. One can select a single file as an entry-point. However, if there are several files which are to be taken in consideration, make sure to use the <a href="#preprocessing">include directive</a> in order to copy all the content needed in a single file which will be at the end executed. By copy, one should understand the automatic preprocessing stage done by the Alk interpreter. The files on the disk won't be modified.

        <table border = 1>
          <tr><th>Syntax</th></tr>
          <tr><td><code>-a "file-path"</code></td></tr>
        </table>

        <b>File-path:</b><br>
        This component should be replaced with a proper path toward a file containing an alk algorithm. The interpreter will consider the file there as the entry-point. The path can be either absolute or relative. In case the path is relative, the origin will be the current working directory.<br>
        <b>Examples:</b>
        <table border = 1>
          <tr><th>Command line</th><th>Description</th></tr>
          <tr><td><code>./alki.sh -a "main.alk"</code></td><td>the option will tell the interpreter to start interpreting the <code>main.alk</code> file (Linux/Mac)</td></tr>
          <tr><td><code>./alki.sh -a "/home/user/work/main.alk"</code></td><td>the option will tell the interpreter to start interpreting the <code>/home/user/work/main.alk</code> file (Linux/Mac)</td></tr>
          <tr><td><code>alki.bat -a "main.alk"</code></td><td>the option will tell the interpreter to start interpreting the <code>main.alk</code> file (Windows)</td></tr>
          <tr><td><code>alki.bat -a "C:\work\main.alk"</code></td><td>the option will tell the interpreter to start interpreting the <code>C:\work\main.alk</code> file (Windows)</td></tr>
        </table> 

      </section>

      <section id="option-i">
        <h2> 3.2 Setting the initial configuration</h2>
        The initial configuration option will allow the user to set a starting environment. This should be used when testing an algorithm with specific testcases. These testcases should follow the syntax described in the <a href="#introduction_2">configuration</a> section. The same type of configuration will be eventually showed by the interpreter (if using the <a href="#option-m"> metadata option</a>) and can be used as input for other algorithms.

        <table border = 1>
          <tr><th>Syntax</th></tr>
          <tr><td><code>-i "configuration"</code></td></tr>
          <tr><td><code>-i "file-path"</code></td></tr>
        </table>

        <b>Configuration:</b><br>
        The configuration can be written inline. This means that the interpreter will parse the value of the option in order to retrieve the configuration. Note that no spaces should be used inside and the string quotes should be skipped using the backslash character.<br>
        <b>File-path:</b><br>
        As an alternative, one can pass the path to a file containing the initial configuration. This is in fact the recommended version as it is more flexible in terms of syntax. The path can be either absolute or relative. If the relative path is used, the origin is the working directory. <br>

        Note that in the examples below, the -a option is required in order to specify an entry-point file and trigger the execution. Also, the extension for the file used as input doesn't matter (in the examples the fictive <code>.in</code> extension is used).<br>

        <b>Examples:</b>
        <table border = 1>
          <tr><th>Command line</th><th>Description</th></tr>
          <tr><td><code>./alki.sh -a "main.alk" -i "a|->12b|->15"</code></td><td>the option will tell the interpreter to use the specified starting configuration (Linux/Mac)</td></tr>
          <tr><td><code>./alki.sh -a "main.alk" -i "main.in"</code></td><td>the option will tell the interpreter to use the content in the <code>main.in</code> as starting configuration (Linux/Mac)</td></tr>
          <tr><td><code>./alki.sh -a "main.alk" -i "/home/user/work/main.in"</code></td><td>the option will tell the interpreter to use the content in the <code>/home/user/work/main.in</code> as starting configuration (Linux/Mac)</td></tr>
          <tr><td><code>alki.bat -a "main.alk" -i "a|->12b|->15"</code></td><td>the option will tell the interpreter to use the specified starting configuration (Windows)</td></tr>
          <tr><td><code>alki.bat -a "main.alk" -i "main.in"</code></td><td>the option will tell the interpreter to use the content in the <code>main.in</code> as starting configuration (Windows)</td></tr>
          <tr><td><code>alki.bat -a "main.alk" -i "C:\work\main.in"</code></td><td>the option will tell the interpreter to use the content in the <code>C:\work\main.in</code> as starting configuration (Windows)</td></tr>
        </table> 

      </section>

      <section id="option-p">
        <h2> 3.3 Setting the precision</h2>
        The precision option is used in order to specify the number of digits which should be used after the floating point when using float operations. If this option is not used, the default of 10 is used. In case the precision is not that important, one can set a lower precision like 1 or 2. If computations with higher precision should be used, one should set this option to numbers greater than 10.

        <table border = 1>
          <tr><th>Syntax</th></tr>
          <tr><td><code>-p digits</code></td></tr>
        </table>

        <b>Digits:</b><br>
        The digits component should be replaced with a valid positive integer. The number here will represent the number of digits after the floating point when float operations are used.<br>

        <b>Examples:</b>
        <table border = 1>
          <tr><th>Command line</th><th>Description</th></tr>
          <tr><td><code>./alki.sh -a "main.alk" -p 2</code></td><td>the option will tell the interpreter to use a precision of 2 decimals after the floating point (Linux/Mac)</td></tr>
          <tr><td><code>./alki.sh -a "main.alk" -p 200 </code></td><td>the option will tell the interpreter to use a precision of 200 decimals after the floating point (Linux/Mac)</td></tr>
          <tr><td><code>./alki.sh -a "main.alk" </code></td><td>the lack of this option will tell the interpreter to use a precision of 10 decimals after the floating point (Linux/Mac)</td></tr>
          <tr><td><code>alki.bat -a "main.alk" -p 2</code></td><td>the option will tell the interpreter to use a precision of 2 decimals after the floating point (Windows)</td></tr>
          <tr><td><code>alki.bat -a "main.alk" -p 200</code></td><td>the option will tell the interpreter to use a precision of 200 decimals after the floating point (Windows)</td></tr>
          <tr><td><code>alki.bat -a "main.alk"</code></td><td>the lack of this option will tell the interpreter to use a precision of 10 decimals after the floating point (Windows)</td></tr>
        </table> 

      </section>

      <section id="option-m">
        <h2> 3.4 Show the metadata</h2>
        This option is used in order to trigger the metadata showing. The metadata represents the final configuration and eventually information about the execution: if it was deterministic, probabilistic or nondeterminstic. If the execution was probabilistic, the probability will be printed. Note that this is a boolean option, which means that no value should be assigned to the option. The simple presence of this option will trigger the behavior described.

        <table border = 1>
          <tr><th>Syntax</th></tr>
          <tr><td><code>-m</code></td></tr>
        </table>

        <b>Examples:</b>
        <table border = 1>
          <tr><th>Algorithm stored in <code>main.alk</code></th><th>Command line</th><th>Platform</th><th>Output</th></tr>
          <tr><td><code>a = 8;<br> b = 10;<br> c = a * b;<br>print("abc");</code></td><td><code>./alki.sh -a "main.alk" -m</code></td><td>Linux/Mac</td><td><code>"abc"<br>a |-> 8<br>b |-> 10<br>c |-> 80</code></td></tr>
          <tr><td><code>a = 8;<br> choose x in [1..a];<br>print(x);</code></td><td><code>./alki.sh -a "main.alk" -m</code></td><td>Linux/Mac</td><td><code>5<br>a |-> 8<br>x |-> 5<br>Note that the executed algorithm is nondeterministic.</code></td></tr>
          <tr><td><code>a = 8;<br> x = random(a);<br>print(x);</code></td><td><code>./alki.sh -a "main.alk" -m</code></td><td>Linux/Mac</td><td><code>5<br>a |-> 8<br>x |-> 5<br>Note that the executed algorithm is probabilistic.<br>The probability for this execution is: 0.125</code></td></tr>
          <tr><td><code>a = 8;<br> b = 10;<br> c = a * b;<br>print("abc");</code></td><td><code>alki.bat -a "main.alk" -m</code></td><td>Windows</td><td><code>"abc"<br>a |-> 8<br>b |-> 10<br>c |-> 80</code></td></tr>
          <tr><td><code>a = 8;<br> choose x in [1..a];<br>print(x);</code></td><td><code>alki.bat -a "main.alk" -m</code></td><td>Windows</td><td><code>5<br>a |-> 8<br>x |-> 5<br>Note that the executed algorithm is nondeterministic.</code></td></tr>
          <tr><td><code>a = 8;<br> x = random(a);<br>print(x);</code></td><td><code>alki.bat -a "main.alk" -m</code></td><td>Windows</td><td><code>5<br>a |-> 8<br>x |-> 5<br>Note that the executed algorithm is probabilistic.<br>The probability for this execution is: 0.125</code></td></tr>
        </table> 
      </section>

      <section id="option-z">
        <h2> 3.5 Increase maximum allocation size</h2>
        This option allows the increasing of the maximum allocation size of one compound data type. All of these dimensions are capped to one billion elements by default, but can be altered through this option. Such capping is a sanity measure to ensure that the dynamic allocation does not overflow. This can somehow limit the memory used by Alk compound data type values.

        <table border = 1>
          <tr><th>Syntax</th></tr>
          <tr><td><code>-z size</code></td></tr>
        </table>

        <b>Size: </b><br>
        The size component should be replaced with a valid positive integer number which will symbolize the maximum number of elements allowed inside one compound data. Note that this does not refer to physical memory, so this number is not the number of bytes or similar.<br>

        <b>Examples:</b>
        <table border = 1>
          <tr><th>Command line</th><th>Description</th></tr>
          <tr><td><code>./alki.sh -a "main.alk" -z 2</code></td><td>the option will tell the interpreter to allow the compound data values to store at most two elements (Linux/Mac)</td></tr>
          <tr><td><code>./alki.sh -a "main.alk" -p 2000000000 </code></td><td>the option will tell the interpreter to allow the compound data values to store at most 2 billion elements (Linux/Mac)</td></tr>
          <tr><td><code>./alki.sh -a "main.alk" </code></td><td>the lac of this option will tell the interpreter to allow the compound data values to store at most 1 billion elements (Linux/Mac)</td></tr>
          <tr><td><code>alki.bat -a "main.alk" -p 2</code></td><td>the option will tell the interpreter to allow the compound data values to store at most two elements (Windows)</td></tr>
          <tr><td><code>alki.bat -a "main.alk" -p 2000000000</code></td><td>the option will tell the interpreter to allow the compound data values to store at most 2 billion elements (Windows)</td></tr>
          <tr><td><code>alki.bat -a "main.alk"</code></td><td>the lack of this option will tell the interpreter to allow the compound data values to store at most 1 billion elements (Windows)</td></tr>
        </table> 
      </section>

      <section id="option-e">
        <h2> 3.6 Trigger exhaustive execution</h2>
        The exhaustive execution option is a very powerful feature of Alk. It allows the user to generate multiple executions when using nondeterministic algorithms such that the final executionResult is in fact an exhaustive search over all choices. This is highly valuable as it makes use of multithreading, so an efficient way of computing the results for nondeterminstic algorithms. Note that the option is a boolean option, meaning that it should not have any value assigned to it. The simple presence of this option will tell the interpreter to split the execution when a choose statement is found, such that all choice paths are evaluated in parallel.

        <table border = 1>
          <tr><th>Syntax</th></tr>
          <tr><td><code>-e</code></td></tr>
        </table>

        Note that the output is grouped for each execution, this means that the written lines are separated for each execution path. However, they are not sorted in any way. As a common fact, the shorter executions will be written first, while the executions which are way more complex are written at the end (as they end up later).

        <b>Examples:</b>
        <table border = 1>
          <tr><th>Algorithm in <code>main.alk</code></th><th>Command line</th><th>Platform</th><th>Output</th></tr>
          <tr><td><code>a = 4;<br>choose x in [1..a];<br>print(x);</code></td><td><code>./alki.sh -a "main.alk" -e</code></td><td>Linux/Mac</td><td>4<br>Note that the executed algorithm is nondeterministic.<br>2<br>Note that the executed algorithm is nondeterministic.<br>1<br>Note that the executed algorithm is nondeterministic.<br>3<br>Note that the executed algorithm is nondeterministic.</td></tr>
          <tr><td><code>choose x in [1..3];<br>for (i=0; i < pow(10, 4) * x; i++)<br> &nbsp;&nbsp; continue;<br>print(x);</code></td><td><code>./alki.sh -a "main.alk" -e</code></td><td>Linux/Mac</td><td>1<br>Note that the executed algorithm is nondeterministic.<br>2<br>Note that the executed algorithm is nondeterministic.<br>3<br>Note that the executed algorithm is nondeterministic.</td></tr>

          <tr><td><code>a = 4;<br>choose x in [1..a];<br>print(x);</code></td><td><code>alki.bat -a "main.alk" -e</code></td><td>Windows</td><td>4<br>Note that the executed algorithm is nondeterministic.<br>2<br>Note that the executed algorithm is nondeterministic.<br>1<br>Note that the executed algorithm is nondeterministic.<br>3<br>Note that the executed algorithm is nondeterministic.</td></tr>
          <tr><td><code>choose x in [1..3];<br>for (i=0; i < pow(10, 4) * x; i++)<br> &nbsp;&nbsp; continue;<br>print(x);</code></td><td><code>alki.bat -a "main.alk" -e</code></td><td>Windows</td><td>1<br>Note that the executed algorithm is nondeterministic.<br>2<br>Note that the executed algorithm is nondeterministic.<br>3<br>Note that the executed algorithm is nondeterministic.</td></tr>
        </table> 

      </section>

      <section id="option-h">
        <h2> 3.7 Help and version</h2>
        The help and version options are used in order to retrieve some information not execution related. This is why these are the only options which can be used without providing an entry-point file with the -a option. The help option provides a list of options which can be used and a short description for each of those. The version option will show the current version used of Alk. Note that these are boolean values.

        <table border = 1>
          <tr><th>Syntax</th></tr>
          <tr><td><code>-h</code></td></tr>
          <tr><td><code>-v</code></td></tr>
        </table>

        <b>Examples:</b>
        <table border = 1>
          <tr><th>Command line</th><th>Description</th></tr>
          <tr><td><code>./alki.sh -h</code></td><td>this will show the list of options and how they should be used (Linux/Mac)</td></tr>
          <tr><td><code>./alki.sh -v</code></td><td>this will show the version of the used Alk (Linux/Mac)</td></tr>
          <tr><td><code>alki.bat -h</code></td><td>this will show the list of options and how they should be used (Windows)</td></tr>
          <tr><td><code>alki.bat -v</code></td><td>this will show the version of the used Alk (Windows)</td></tr>
        </table> 
      </section>

    </section>
    
    <footer>
        <p> <b> Alk Reference Manual </b> </p>
        <p> written by Lungu Alexandru-Ioan </p>
        <p> scientific coordinator Prof. dr. Lucanu Dorel </p>
        <p> Faculty of Computer Science, UAIC Iasi </p>
    </footer>

</body>

</html>