
// the root of an AST
root(ast) {
  if (ast.size() > 0) return ast[0];
}


// the number of children
chldNo(ast) {
  if (ast.size() > 0) return ast[1].size();
  return 0;
}

// the i-th child of an AST
chld(ast, i) {
  if (ast.size() > 0 && i < ast[1].size()) {
    return ast[1].at(i);
  }
}

// updates a child
updatedChld(ast, i, newchld) {
  if (ast.size() > 0 && ast[1].size() > 0)
    if (i >= 0 && i < ast[1].size()) {
      ast[1].update(i, newchld);
      return ast;
    }
}

// removes a child
removedChld(ast, i) {
  if (ast.size() > 0 && ast[1].size() > 0)
    if (i >= 0 && i < ast[1].size()) {
      ast[1].removeAt(i);
      return ast;
    }
}

/* tests: */
print(updatedChld(["_+_", <["a", <>], ["", <>]>], 1, ["b", <>]));
print(updatedChld(["_+_", <["a", <>], ["", <>]>], 0, ["b", <>]));
print(updatedChld(["_+_", <["a", <>], ["", <>]>], 2, ["b", <>]));



// the string representation of an AST
ast2string(ast) {
  if (ast == []) str = "";
  else if (chldNo(ast) == 0) str = root(ast);
  else if (root(ast) == "_+_") {
    str = "(" + ast2string(chld(ast,0));
    n = chldNo(ast);
    for (i = 1; i < n; ++i)
      str = str + " + " + ast2string(chld(ast, i));
    str = str + ")";
  }
  else if (root(ast) == "_._") {
    str = ast2string(chld(ast,0));
    n = chldNo(ast);
    for (i = 1; i < n; ++i)
      str = str + ast2string(chld(ast, i));
  }
  else if (root(ast) == "_*")
    str = ast2string(chld(ast, 0)) + "*";
  else
    return "undefined";
  return str;
}

/* tests:
print(ast2string(["_._", <["a", <>], ["b", <>]>]));
print(ast2string(["_._", <["a", <>], ["_*", <["_+_", <["a", <>], ["b", <>]>]>], ["_._", <["a", <>], ["b", <>]>]>]));
*/

/*
 epsIn(E) stands for true if L(E) contains the empty string;
 otherwise, espIn(E) stands for 0.
*/
epsIn(ast) {
  if (ast == []) return false;
  if (root(ast) == "")  // eps
    return true;
  if (root(ast) == "_+_") {
    answ = epsIn(chld(ast, 0));
    for (i = 1; i < chldNo(ast); ++i)
      asw = answ || epsIn(chld(ast, i));
    return answ;
  }
  if (root(ast) == "_._") {
    answ = epsIn(chld(ast, 0));
    for (i = 1; i < chldNo(ast); ++i)
      asw = answ && epsIn(chld(ast, i));
    return answ;
  }
  if (ast[0] == "_*")
    return true;
  return false;
}

/*
tests:
print(epsIn(["_._", <["a", <>], ["a", <>]>]));
print(epsIn(["_+_", <["a", <>], ["", <>]>]));
*/

/*
 Brzozowski's derivatives:
 lang(der(E,a)) = {w | aw in lang(E)}
*/
der(ast, a) {
  if (ast == []) astder = [];
  else if (chldNo(ast) == 0) {
    if (root(ast) == a) astder = ["", <>];
    else astder = [];
  }
  else if (root(ast) == "_+_") {
    chlds = <>;
    for (i = 0; i < chldNo(ast); ++i)
      chlds.pushBack(der(chld(ast,i), a));
    astder = ["_+_", chlds];
  }
  else if (root(ast) == "_._") {
    chlds = <der(chld(ast,0), a)>;
    for (i = 1; i < chldNo(ast); ++i)
      chlds.pushBack(chld(ast,i));
    chlds = < ["_._", chlds] >;
    for (i = 0; i < chldNo(ast); ++i) {
      if (epsIn(chld(ast, i)) && i < chldNo(ast) - 1) {
        chlds2 = <der(chld(ast,i + 1), a)>;
        for (j = i + 2; j < chldNo(ast); ++j)
          chlds2.pushBack(chld(ast,j));
        chlds.pushBack(["_._", chlds2]);
      }
    }
    if (chlds.size() == 1)
      astder = chlds.at(0);
    else
      astder = ["_+_", chlds];
  }
  else if (ast[0] == "_*")
    astder = ["_._", < der(chld(ast, 0), a), ast >];
  return astder;
}

/*
tests:
print(ast2string(["_._", <["a", <>], ["b", <>]>]));
print(ast2string(der(["_._", <["a", <>], ["b", <>]>], "a")));
print(ast2string(["_._", <["a", <>], ["_*", <["_+_", <["a", <>], ["b", <>]>]>], ["_._", <["a", <>], ["b", <>]>]>]));
print(ast2string(der(["_._", <["a", <>], ["_*", <["_+_", <["a", <>], ["b", <>]>]>], ["_._", <["a", <>], ["b", <>]>]>], "a")));
print(ast2string(["_+_", <["a", <>], ["b", <>]>]));
print(ast2string(der(["_+_", <["a", <>], ["b", <>]>], "a")));
print(ast2string(["_*", <["_+_", <["a", <>], ["b", <>]>]>]));
print(ast2string(der(["_*", <["_+_", <["a", <>], ["b", <>]>]>], "a")));
*/


/*
  Simplifies an AST using the unit/domination law
  for empty and eps
  TODO: add the associativity law for _+_ and _._
*/
simplify1(ast) {
  if (ast == [])   // empty
    return ast;
  if (len(root(ast)) <= 1)  // eps or in Sigma
    return ast;
  if (root(ast) == "_+_" ) // a sum expression
    for (i = 0; i < chldNo(ast); ++i)
      if (chld(ast, i) == [])   //i-th child is empty
        ast = removedChld(ast, i);
      else  //i-th child is non-empty
        ast = updatedChld(ast, i, simplify1((chld(ast, i))));
    if (chldNo(ast) == 0)
      return [];
    else if (chldNo(ast) == 1)
      return chld(ast,0);
    else
      return ast;
  if (root(ast) == "_._" ) {  // a product expression
    for (i = 0; i < chldNo(ast); ++i) {
      if (chld(ast, i) == [])  //i-th child is empty
        return [];
      else if (root(chld(ast, i)) == "")   //i-th child is eps
        ast = removedChld(ast, i);
      else   //i-th child is non-empty or eps
        ast = updatedChld(ast, i, simplify1((chld(ast, i))));
    }
    if (chldNo(ast) == 0) // removed all children
      return ["", <>];
    else if (chldNo(ast) == 1) // just one child remained
      return chld(ast,0);
    else  // at least two children
      return ast;
  }
  if (root(ast) == "_*") // a star expression
    if (chld(ast, 0) == []) // empty
      return [];
    else
      return ["_*", < simplify1(chld(ast, 0)) >];
  return ast;
}


/*
tests:
print(der(["_._", <["a", <>], ["b", <>]>], "a"));
print(simplify1(der(["_._", <["a", <>], ["b", <>]>], "a")));
print(der(["_+_", <["a", <>], ["b", <>]>], "a"));
print(simplify1(der(["_+_", <["a", <>], ["b", <>]>], "a")));
print(der(["_*", <["_+_", <["a", <>], ["b", <>]>]>], "a"));
print(simplify1(der(["_*", <["_+_", <["a", <>], ["b", <>]>]>], "a")));
print(simplify1(simplify1 (der(["_*", <["_+_", <["a", <>], ["b", <>]>]>], "a"))));
print(["_+_", <[], []>]);
print(simplify1(["_+_", <[], []>]));
*/

simplify(ast) {
/*
  do {
print("&&&&&");
print(ast);
    ast1 = ast;
    ast = simplify1(ast1);
print("-----");
print(ast);
print(ast1);
  } while (ast != ast1);
  return ast1;
*/
  ast1 = simplify1(simplify1(simplify1(simplify1(simplify1(simplify1(ast))))));
  return ast1;
}



//print((simplify (der(["_._", <["_*", <["_+_", <["_._", <["a", <>], ["b", <>]>], ["b", <>]>]>], ["b", <>], ["a", <>]>], "a"))));
//print((simplify (der(["_._", <["_*", <["_+_", <["_._", <["a", <>], ["b", <>]>], ["b", <>]>]>], ["b", <>], ["a", <>]>], "b"))));
//print(simplify1 (simplify1 (simplify1 (der(["_._", <["_*", <["_+_", <["_._", <["a", <>], ["b", <>]>], ["b", <>]>]>], ["b", <>], ["a", <>]>], "c")))));
//print((simplify (der(["_._", <["_*", <["_+_", <["_._", <["a", <>], ["b", <>]>], ["b", <>]>]>], ["b", <>], ["a", <>]>], "c"))));


/*
print(["_._", < ["_+_", <[], []>], ["_._", < ["a", <>], ["_._", <["", <>], ["", <>]>] >]>]);
print(simplify(["_._", < ["_+_", <[], []>], ["_._", < ["a", <>], ["_._", <["", <>], ["", <>]>] >]>]));
print(der(["_*", <["_+_", <["a", <>], ["b", <>]>]>], "a"));
print(simplify(der(["_*", <["_+_", <["a", <>], ["b", <>]>]>], "a")));
*/

getState (map, str) {
  forall pair in map
    if(pair[1] == str)
      return pair[0];
}


/*
  Brzozowski's automaton
*/
detAut(ast, Sigma) {
  state = 0;
  aut = {};
  ast = simplify(ast);
//  map = < [state, ast2string(ast)] >;
  map = < [state, ast] >;
  derSet = { ast };
  do {
forall x in derSet print(ast2string(x));
print("");
    derSet1 = derSet;
    forall s in Sigma
      forall ast in derSet1 {
        ast1 = simplify(der(ast, s));
        if (!(ast1 in derSet) && ast1 != []) {
          derSet = derSet U { ast1 };
	  state++;
	  //str = ast2string(ast1);
	  str = ast1;
	  if (epsIn(ast1))
            map.pushBack([state, str,"acc"]);
	  else
	    map.pushBack([state, str]);
//	  aut = aut U { < getState(map,  ast2string(ast)), s, state > };
	}
      }
  } while (derSet != derSet1);
  forall p in map
    forall q in map
      forall s in Sigma
        if (q[1] == simplify(der(p[1], s)))
	  aut = aut U { < p[0], s, q[0] > };
  return [aut, map];
}

//print(detAut(["_+_", <["_*", <["_+_", <["_._", <["a", <>], ["c", <>]>], ["c", <>]>]>], ["_*", <["_+_", <["_._", <["a", <>], ["a", <>]>], ["b", <>]>]>]>], ["a", "b", "c"]));

print(detAut(["_._", <["_*", <["_+_", <["_._", <["a", <>], ["b", <>]>], ["b", <>]>]>], ["b", <>], ["a", <>]>], ["a", "b", "c"]));

/*
print(ast2string (der(["_._", <["_*", <["_+_", <["_._", <["a", <>], ["b", <>]>], ["b", <>]>]>], ["b", <>], ["a", <>]>], "a")));
print(ast2string (der(["_._", <["_*", <["_+_", <["_._", <["a", <>], ["b", <>]>], ["b", <>]>]>], ["b", <>], ["a", <>]>], "b")));
print(ast2string (der(["_._", <["_*", <["_+_", <["_._", <["a", <>], ["b", <>]>], ["b", <>]>]>], ["b", <>], ["a", <>]>], "c")));
*/

//print(detAut(["a", <>],  ["a", "b", "c"]));

