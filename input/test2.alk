all_distinct(a, m)
// analiza statica la requires/cod -> tipuri de date
// havoc
// evaluare requires, adaugare la path condition
requires a : array<boolean> && m : array<int>
requires forall i : int :: 0 <= i && i < a.size() ==> 0 <= a[i] && a[i] < m
ensures  result <==> (forall i : int, j : int :: 0 <= i && i < a.size() ==>
         (0 <= j && j < a.size() ==> (i != j ==> a[i] != a[j])))
ensures  result : boolean
{
    // ap = [false | _ from [0..m-1]];
    // ap = emptyArray<boolean>;

    ap = [];

    // AlkArray : AlkValue
    // size, elementele, tip de date ale elementelor

    assume ap : array<boolean>;

    ap = [false];
    i = 1;

    while (i < m)
    invariant i <= m
    invariant i == ap.size()
    invariant forall k : boolean :: k in ap ==> k == false
    modifies i, ap
    {
        ap[i] = false;
        i++;
    }

    assert ap.size() == m;
    assert !(true in ap);

    k = 0;
    ok = true;
    while (k < a.size())
    invariant k <= a.size()
    invariant ok <==> (forall i : int, j : int :: 0 <= i && i < k ==>
                      (0 <= j && j < k ==> (i != j ==> a[i] != a[j])))
    modifies ap, ok, k
    {
        v = a[k];
        if (ap[v])
        {
            ok = false;
        }
        ap[v] = true;
        k++;
    }

    assert k == a.size();

    return ok;
}


requires a : array<int>


a : array<int>

pc |-> $a == 2 && b && c &&
pc: $a : array<int>

// ap = [f(x) | x from A];
// ============================== A -> array/list
// env: ap |-> $ap_0
// pc:  $ap_0.size() == A.size() && forall i : int :: 0 <= i && i < A.size() ==> ap[i] == f(A[i])

// ap = [x..y];
// ==============================
// env: ap |-> $ap_0
// pc:  $ap_0.size() == y - x + 1 && forall i : int :: 0 <= i && i < y - x + 1 ==> $ap_0[i] == x + i

// ap = [x from A | f(x)];
// $s_0
// =====================================
// env: ap |-> $ap_0
// pc: $ap_0 ==