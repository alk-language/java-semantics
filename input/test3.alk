swap(out a, out b)
requires true
ensures old(a) == b && old(b) == a
{
    tmp = a;
    a = b;
    b = tmp;
}

sorted(a)
{
    return sorted2(a, a.size());
}

sorted2(a, i)
{
    return forall k : int :: 0 < k && k < i ==> a[k - 1] <= a[k];
}

findMin(a, i)
requires ...
requires ...
ensures ...
ensures ...
{
    assume 0 <= i && i < a.size();
    // requires 0 <= i < a.Length
    j = i;
    m = i;

    while(j < a.size())
        invariant i <= j && j <= a.size()
               && i <= m && m < a.size()
               && (forall k : int :: i <= k && k < j ==> a[k] >= a[m])
        modifies m, j
    {
        if(a[j] < a[m]) m = j;
        j++;
    }

    assert i <= m && m < a.size(); // ensures i <= m < a.Length
    assert forall k : int :: i <= k && k < a.size() ==> a[k] >= a[m];
    // ensures forall k :: i <= k < a.Length ==> a[k] >= a[m]
    return m;
}

insertionSort(out a) uses a
{
    c = 0;
    while(c < a.size())
        invariant 0 <= c && c <= a.size()
               && (forall k : int, l : int :: 0 <= k && k < c && c <= l && l < a.size() ==> a[k] <= a[l])
               && sorted2(a, c)
        modifies a, c
    {
        m = findMin(a, c);
        swap(a[m], a[c]);
        assert forall k : int :: c <= k && k < a.size() ==> a[k] >= a[c];
        c++;
    }

    assert sorted(a);
}

symbolic $a : array<int>;
a = $a;
insertionSort(a);



// findMin(input, output) modifies ... uses ...
// requires r
// ensures e
//    s

// 1) havoc input, output, modifies, uses
// 2) assume r
// 3) execute s
// 4) assert e



// findMin(input, output)

// 1) evaluare argumente si initializare parametrii de intrare
// 2) assert r
// 3) havoc output, modifies
// 4) assume e

abs(x) ...

b |-> $b
c |-> $c
abs(b + c)


a |-> (store a m loc)
loc |-> (select a m)
======================
a |-> (store a m loc)
loc |-> fresh