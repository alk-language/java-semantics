/*

 Sigma ::= "a" | "b" | "c"
 
 expression ::= term ("+" term)* 
 
 term ::= factor ["*"]
        | factor ["*"] ("." factor ["*"])* 

   TODO: add a representation for "eps"
 
 factor ::=
     Sigma
     | "(" expression ")"

*/


// the current position in the input
index = 0;

// the current symbol
sym() modifies index, input {
  if (index < input.size())
    return input.at(index);
  return "\0";
}

// goes to the next symbol
nextSym() modifies index, input {
  if (index < input.size()) {
    index++;
/*
    // skip the spaces
    while (input.at(index) == " " && index < input.size())
    index++;
*/
  } else
    error("nextsym: expected a symbol");
}

// prints an error message
error(msg) modifies index {
  print(msg + " at position ");
  print(index);
  print("");
}

/*
  tests if the current symbol is accepted and
  if yes, advances in the input
*/
accept(s, out ast) {
    if (sym() == s) {
        nextSym();
	ast = [s, <>];
        return true;
    }
    return false;
}

/*
  test if the current symbol is in the alphabet Sigma and
  if yes, advances in the input
*/
acceptSigma(out ast) modifies sigma {
  for (i = 0; i < sigma.size(); ++i) 
      if (accept(sigma[i], ast)) {
        return true;
      }
  return false;
}

// test if the current symbol is the exptected one
expect(s) {
    ast = [];
    if (accept(s, ast))
        return true;
    error("expect: unexpected symbol");
    return false;
}

// parses a factor and returs its AST
factor() {
    ast = [];
    if (acceptSigma(ast)) {
      return ast;
    } else if (accept("(", ast)) {
        ast = expression();
        expect(")");
    }
        return ast;
}

// parses a term and returs its AST
term() {
    ast = factor();
    list = < ast >;
    if (accept("*", ast)) list = < ["_*", list] >;
    while (sym() == ".") {
        nextSym();
        ast1 = factor();
	if (accept("*", ast)) list.pushBack(["_*", < ast1 >]);
	else list.pushBack(ast1);
    }
    if (list.size() > 1)
      return ["_._", list];
    else
      return list.at(0);
}

// parses an epression and returs its AST
expression() {
    ast = term();
    list = < ast >;
    while (sym() == "+") {
        nextSym();
        ast = term();
	list.pushBack(ast);
    }
    if (list.size() > 1)
      return ["_+_", list];
    else
      return list.at(0);
}
// the alphabet
sigma = ["a","b","c"];
// the expression
input = "(a.b+b)*.(b.a)";
print(expression());
