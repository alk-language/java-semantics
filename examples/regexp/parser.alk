/*

 Sigma ::= "a" | "b" | "c"
 
 expression = term ("+" term)* .
 
 term = factor "*"
     | factor ("." factor)* .
 /*
   TODO: add a representaion for "eps"
 */
 factor =
     Sigma
     | "(" expression ")".

*/

// the input expression
//input = ["a", ".", "a"];  // aa
//input = ["(","a",".","a","+","b",")","*"];  // (aa + b)* 
//input = ["(", "a", ".", "c", "+", "c",")", "*", "+", "(","a",".","a","+","b",")","*"]; // (ac+c)*+(aa+b)*
input = ["(","a",".","b","+","b",")","*", ".", "b", ".", "a"];  // (ab + b)*ba

// the current position in the input
index = 0;

// the alphabet
sigma = ["a","b","c"];

// the current symbol
sym() modifies index, input {
  if (index < input.size())
    return input[index];
  return "\0";
}

// goes to the next symbol
nextSym() modifies index, input {
  if (index < input.size()) {
    index++;
/*
    // skip the spaces
    while (input[index] == " " && index < input.size())
    index++;
*/
  } else
    error("nextsym: expected a symbol");
}

// prints an error message
error(msg) modifies index {
  print(msg + " at position ");
  print(index);
  print("");
}

// tests if the current symbol is accepted and
// if yes, returns its AST
accept(s, out ast) {
    if (sym() == s) {
        nextSym();
	ast = [s, <>];
        return true;
    }
    return false;
}

// test if the current symbol is in the alphabet Sigma and
// if yes, returns its AST
acceptSigma(out ast) modifies sigma {
  for (i = 0; i < sigma.size(); ++i) 
      if (accept(sigma[i], ast)) {
        return true;
      }
  return false;
}

// test if the current symbol is the exptected one
expect(s) {
    ast = [];
    if (accept(s, ast))
        return true;
    error("expect: unexpected symbol");
    return false;
}

// parses a factor and returs its AST
factor() {
    ast = [];
    if (acceptSigma(ast)) {
      return ast;
    } else if (accept("(", ast)) {
        ast = expression();
        expect(")");
    }
        return ast;
}

// parses a term and returs its AST
term() {
    ast = factor();
    list = < ast >;
    if (accept("*", ast)) list = < ["_*", list] >;
    while (sym() == ".") {
        nextSym();
        ast1 = factor();
	if (accept("*", ast)) list.pushBack(["_*", < ast1 >]);
	else list.pushBack(ast1);
    }
    if (list.size() > 1)
      return ["_._", list];
    else
      return list.at(0);
}

// parses an epression and returs its AST
expression() {
    ast = term();
    list = < ast >;
    while (sym() == "+") {
        nextSym();
        ast = term();
	list.pushBack(ast);
    }
    return ["_+_", list];
}

// print(factor());
 print(term());
// expect("+");
// print(factor());
/*
print(term());
expect("+");
print(term());
*/
//print(expression());

