/*

 Sigma ::= "a" | "b" | "c"
 
 expression = term ("+" term)* .
 
 term = factor "*"
     | factor ("." factor)* .
 
 factor =
     Sigma
     | "(" expression ")".

*/

// the input expression
input = ["(","a",".","a","+","b",")","*"];

// the current position in the input
index = 0;

// the alphabet
sigma = ["a","b","c"];

// the current symbol
sym() modifies index, input {
  return input[index];
}

// goes to the next symbol
nextSym() modifies index, input {
  if (index < input.size()) {
    index++;
/*
    // skip the spaces
    while (input[index] == " " && index < input.size())
    index++;
*/
  } else
    error("nextsym: expected a symbol");
}

// prints an error message
error(msg) modifies index {
  print(msg + " at position ");
  print(index);
  print("");
}

// tests if the current symbol is accepted and
// if yes, returns its AST
accept(s, out ast) {
    if (sym() == s) {
        nextSym();
	ast = [s, <>];
        return true;
    }
    return false;
}

// test if the current symbol is in the alphabet Sigma and
// if yes, returns its AST
acceptSigma(out ast) modifies sigma {
  for (i = 0; i < sigma.size(); ++i) 
      if (accept(sigma[i], ast)) {
        return true;
      }
  return false;
}

// test if the current symbol is the exptected one
expect(s) {
    ast = [];
    if (accept(s, ast))
        return true;
    error("expect: unexpected symbol");
    return false;
}

// parses a factor and returs its AST
factor() {
    ast = [];
    if (acceptSigma(ast)) {
      return ast;
    } else if (accept("(", ast)) {
        ast = expression();
        expect(")");
//        return ast;
    }
//    error("factor: error");
        return ast;
}

// parses a term and returs its AST
term() {
    ast = factor();
    list = < ast >;
    if (accept("*", ast)) return ["_*", list];
    while (sym() == ".") {
        nextSym();
        ast = factor();
	list.pushBack(ast);
    }
    if (list.size() > 1)
      return ["_._", list];
    else
      return list.at(0);
}

// parses an epression and returs its AST
expression() {
    ast = term();
    list = < ast >;
    while (sym() == "+") {
        nextSym();
        ast = term();
	list.pushBack(ast);
    }
    return ["_+_", list];
}

//print(factor());
print(term());
//expect("+");
//factor();
